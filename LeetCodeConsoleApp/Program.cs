using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;


namespace LeetCodeConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {

            var sol = new Solution();

            //  var l = new ListNode(5); 
            // l.next = new ListNode(4);
            //l.next.next = new ListNode(3);


            //  var l2 = new ListNode(5);
            // l2.next = new ListNode(6);
            // l2.next.next = new ListNode(4);
            //   var a = sol.AddTwoNumbers5(l, l2);




            //sol.SortedSquares(new int[] {-4, -1, 0, 3, 10});
            //var sorted = sol.CustomSortString("cba", "abccd");
            //var a = sol.LongestPalindrome("babad");
            //var b = sol.WordPattern("abba", "dog dog dog dog");



            //var d = sol.MaxDistToClosest(new int[] { 0, 1, 0, 1, 0 }); //, 1, 0, 1 });
            //var root = new TreeNode(1);
            //root.left = new TreeNode(3);
            //root.right = new TreeNode(2);
            //root.left.left = new TreeNode(5);
            //root.left.right = new TreeNode(3);
            //root.right.right = new TreeNode(9);
            //1,3,2,5,3,null,9]

            //   5
            //  / \
            //  3   6
            // / \   \
            //2   4   7

            //  var l = sol.LargestValues(root);



            //var root = new TreeNode(3);
            //root.left = new TreeNode(9);
            //root.right = new TreeNode(20);

            //root.right.left = new TreeNode(15);
            //root.right.right = new TreeNode(7);
            //var f = sol.SumOfLeftLeaves(root);



            // var r = sol.RelativeSortArray2( new int[] { 2, 3, 1, 3, 2, 4, 6, 7, 9, 2, 19 }, new int[] { 2, 1, 4, 3, 9, 6 });

            //   var c = sol.CommonChars(new string [] { "bella", "label", "roller" });


            //var s = sol.TwoSum(new int[] { 3, 2, 4 }, 6);


            //  var s = sol.ProductExceptSelf(new int[] { 1, 2, 3, 4 });
            //var s = sol.ProductExceptSelf(new int[] { 0,0});

            //var s = sol.MaxSubArray(new int[] { -2, 1, -3, 4, -1, 2, 1, -5, 4 });

            // var p = sol.MaxProduct(new int[] { -2, 3, -4 });
            // var m = sol.FindMin(new int[] { 3, 4, 5, 1, 2 });
            //var m = sol.Search(new int[] { 4, 5, 6, 7, 0, 1, 2 }, 8);
            //var s = sol.ThreeSum(new int[] {-1, 0, 1, 2, -1, -4});
            //var m = sol.MaxArea(new int[] { 1, 8, 6, 2, 5, 4, 8, 3, 7});
            //var s = sol.GetSum(2, 6);
            //var h = sol.HammingWeight(11);
            //var r = sol.reverseBits(0b_00000010100101000001111010011100); // (43261596);

            //var p = sol.IsPalindrome("0P"); // ( " A man, a plan, a canal: Panama");

            //var arraytosort = new int[] { 0, 1, 2, 0, 1, 2 };
            //sol.MSInterviewsort012(arraytosort);

            //var l = new ListNode(1); // ListNode(7);
            //l.next = new ListNode(8);
            // l.next.next = new ListNode(3);
            //l.next.next.next = new ListNode(7);

            //var rll = sol.ReverseList(l);

            //  var c = sol.ClimbStairs(5);





            //var lis = sol.LengthOfLIS(new int[] { 10, 9, 2, 5, 3, 7, 101, 18 });

            //var l = new ListNode(3); 
            //l.next = new ListNode(2);
            // l.next.next = new ListNode(0);
            //l.next.next.next = new ListNode(-4);
            //l.next.next.next.next = l.next;

            //var hc = sol.HasCycle(null);

            //var l = new ListNode(1);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(4);

            //var l2 = new ListNode(1);
            //l2.next = new ListNode(3);
            //l2.next.next = new ListNode(4);

            //var l3 = new ListNode(2);
            //l3.next = new ListNode(6);



            //var l4 = new ListNode(-1);
            //var l5 = new ListNode(2);



            //var m2l = sol.MergeTwoLists2(l, l2);


            // var m2l = sol.MergeKLists(new ListNode[]{l5,null,l4});

            //var l = new ListNode(7);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(4);
            //l.next.next.next = new ListNode(3);

            //var l2 = new ListNode(5);
            //l2.next = new ListNode(6);
            //l2.next.next = new ListNode(4);

            ////var r = sol.RemoveNthFromEnd(l, 2);
            //sol.ReorderList(l);

            //var l = sol.LengthOfLongestSubstring("pwwkew");

            // sol.TestIcomparable();
            //var l = new ListNode(9);
            //l.next = new ListNode(1);
            //l.next.next = new ListNode(6);

            //var l2 = new ListNode(0);


            //var a = sol.AddTwoNumbers(l, l2);


            // var r = sol.RestoreString("codeleet", new int[]{ 4, 5, 6, 7, 0, 2, 1, 3});

            //var m = sol.MinTimeToVisitAllPoints(new int[][] { new int[] { 1, 1 }, new int[] { 3, 4 }, new int[] { -1, 0 } });


            //  var sol2 = new Solution2();

            //          var r = sol2.Read(new char[] { 'a','b','c','d','e' }, 4);


            //  var p = sol.MaxProfit(new int[] { 1, 4, 2 }); // 7, 1, 5, 6, 4 });




            //            var ms = sol.MaxSubArrayLen(new int[] { 1, -1, 5, -2, 3 }, 3);
            //  var ms = sol.MaxSubArrayLen2(new int[] { -2, -1, 2, 1 },  1);


            // var ai = sol.ArraysIntersection(new int[] { 1, 2, 3, 4, 5 }, new int[] { 1, 2, 5, 7, 9 }, new int[] { 1, 3, 4, 5, 8 });


            // var ng = sol.NextGreaterElement(new int[] { 4, 1, 2 }, new int[] { 1, 3, 4, 2 });



            //var sp = sol.SimplifyPath("/home//foo//foo2/../");

            //var sp = sol.SimplifyPath("/a/./b/../../c/");

            //  var sp = sol.SimplifyPath("/a/../../b/../c//.//");

            //  var lm = sol.LeftMostColumnWithOne(new int[][] { new int[] { 0,0,0,0 } 
            //  , new int[] { 0,0,0,0 }});

            //  var rv = sol.ReverseVowels("leetcode");


            //  var s = sol.GetSum2(0b1110, 0b0011);


            // var ndt = sol.NetworkDelayTime(new int[][] { new int[] { 2, 1, 1 }, new int[] { 2, 3, 1 }, new int[] { 3, 4, 1 } }, 4, 2);

            //var m = sol.MissingElement(new int[] { 4, 7, 9, 10 }, 1);

            //var ri = sol.RomanToInt("DCXXI");

            // var r = sol.RemoveOuterParentheses("(()())(())(()(()))");


            // var cb = sol.CountBits2(5);


            //  var rb = sol.reverseBits2(0b_00000010100101000001111010011100);
            //   var rb = sol.reverseBits(0b_1101);


            //var n = new Node(1);
            //n.random = null;
            //n.next = new Node(2);
            //n.next.random = n;
            //n.next.next = new Node(3);

            //var c = sol.CopyRandomList(n);


            //var l = new ListNode(1);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(3);
            //l.next.next.next = new ListNode(4);
            //l.next.next.next.next = new ListNode(5);
            // sol.ReorderList2(l);


            // var c = sol.MyAtoi2("2147483646");



            //  var dupes = new int[] { 0, 0, 1, 1, 1, 2, 2, 3, 3, 4 };
            //  var u = sol.RemoveDuplicates(dupes); 


            //  var a = sol.FindAnagrams2("cbaebabacd", "abc");

            // var a = sol.AddStrings("1", "9"); // "6913259244", "71103343");

            //var ip = sol.IsPalindrome2("A man, a plan, a canal: Panama");

            //  var ab = sol.AddBinary("1010", "1011");




            //facebook interview 
            //var grid = new char[][] { new char[] { '-', '-', '-', '-' }, new char[] { '-', '-', '-', '-' }, new char[] { '-', '-', '-', '-' } };
            //sol.generateKMines(grid,3);
            //for (int i = 0; i < grid.Length; i++)
            //{
            //    for (int j = 0; j < grid[0].Length; j++)
            //    {
            //        Console.Write(grid[i][j] + " ");
            //        //System.out.print(grid[i][j] + " ");
            //    }
            //    Console.WriteLine();
            //}

            //var root = new TreeNode(10);
            //root.left = new TreeNode(5);
            //root.right = new TreeNode(15);
            //root.left.left = new TreeNode(3);
            //root.left.right = new TreeNode(7);
            //root.right.right = new TreeNode(18);

            ////  var rs = sol.RangeSumBST(root, 7,15);
            //var ks = sol.KthSmallest(root, 1);
            // var ias = sol.IsAlienSorted(new string[] { "world", "word", "row" }, "worldabcefghijkmnpqstuvxyz");

            // var ias = sol.IsAlienSorted(new string[] { "kuvp", "q" }, "ngxlkthsjuoqcpavbfdermiywz");


            //var ias = sol.IsAlienSorted(new string[] { "apple", "app" },  "abcdefghijklmnopqrstuvwxyz");



            //var ao = sol.AlienOrder(new string []{ "wrt", "wrf", "er", "ett", "rftt" });

            //  var mr = sol.MinRemoveToMakeValid("lee(t(c)o)de)");

            // var po = sol.PlusOne(new int[] { 4, 3, 2, 1 });

            //  var d = sol.deserialize("1 2 3 null null 4 5");


            //var root = new TreeNode(1);
            //root.left = new TreeNode(2);
            //root.right = new TreeNode(3);
            //root.left.right = new TreeNode(5);
            //var btp = sol.BinaryTreePaths(root);


            //var iv = sol.IsValid("([)]");

            //var l = new ListNode(1);
            //l.next = new ListNode(1);
            //l.next.next = new ListNode(1);
            ////l.next.next.next = new ListNode(3);
            ////l.next.next.next.next = new ListNode(3);

            //var dd = sol.DeleteDuplicates(l);

            //  var ci = sol.CheckInclusion("hello", "ooolleoooleh");


            //var wb = sol.WordBreak2("leetcode", new string[] { "leet", "code" });
            //var wb = sol.WordBreak2("aaaaaaa", new string[] { "aaaa", "aaa" });

            // var wb = sol.WordBreak2("applepenapple", new string[] {"apple", "pen"});


            // var io = sol.IsOneBitCharacter(new int[] { 0, 1, 0 });

            // var lt = sol.LargestTimeFromDigits(new int[] { 5, 5, 5, 5 });


            //var q = new MyQueue();
            //q.Push(1);
            //q.Push(2);
            //var p = q.Peek();
            //var pop = q.Pop();
            //var e = q.Empty();


            //var s = new MyStack();
            //s.Push(1);
            //s.Push(2);
            //var p = s.Peek();
            //var pop = s.Pop();
            //s.Push(3);
            //var pop2 = s.Pop();
            //s.Push(4);


            //var root = new TreeNode(3);
            //root.left = new TreeNode(5);
            //root.right = new TreeNode(1);
            //root.left.left = new TreeNode(6);
            //root.left.right = new TreeNode(2);
            //root.right.left = new TreeNode(9);
            //root.right.right = new TreeNode(8);
            //root.left.right.left = new TreeNode(7);
            //root.left.right.right = new TreeNode(4);

            //var root2 = new TreeNode(3);
            //root2.left = new TreeNode(5);
            //root2.right = new TreeNode(1);
            //root2.left.left = new TreeNode(6);
            //root2.left.right = new TreeNode(7);
            //root2.right.left = new TreeNode(4);
            //root2.right.right = new TreeNode(2);
            //root2.right.right.left = new TreeNode(9);
            //root2.right.right.right = new TreeNode(8);

            //var s = sol.LeafSimilar(root, root2);

            //var hw = sol.HammingWeight2(0b_00000000000000000000000000001011);

            //sol.SortColors(new int[] { 2, 0, 1 }); // 2, 1, 1, 0});


            //var root = new TreeNode(5);
            //root.left = new TreeNode(3);
            //root.right = new TreeNode(6);

            //root.left.left = new TreeNode(2);
            //root.left.right = new TreeNode(4);
            //root.left.left.left = new TreeNode(1);



            //var root = new TreeNode(2);
            ////root.left = new TreeNode(3);
            //root.right = new TreeNode(3);


            //var p = new TreeNode(2);
            //var ios = sol.InorderSuccessor2(root, p);




            //var r = sol.RepeatedSubstringPattern("aba"); // ababaab");





            //var l = new ListNode(7);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(4);
            //l.next.next.next = new ListNode(3);

            //var l2 = new ListNode(5);
            //l2.next = new ListNode(6);
            //l2.next.next = new ListNode(4);

            //var a = sol.AddTwoNumbers6(l, l2);




            // var me = sol.MajorityElement(new int[] { 3, 2, 3 });

            //  var nct = sol.NextClosestTime("23:59");
            //var ue = sol.NumUniqueEmails(new string[] { "test.email+alex@leetcode.com", "test.e.mail+bob.cathy@leetcode.com", "testemail+david@lee.tcode.com" });


            //  var tf = sol.TotalFruit(new int[] { 1, 2, 3, 2, 2 });
            // var ntp = sol.NumTilePossibilities("AAB");

            // var n = sol.NumWaterBottles(15, 8);

            // var m = sol.MinSteps("bab", "aba");

            //var l = sol.LengthLongestPath("dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext");

            // var l = new ListNode(5); 
            // l.next = new ListNode(4);
            // l.next.next = new ListNode(3);


            // sol.ReverseList(l);

            // var d = sol.MaxDistToClosest(new int[] {1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0});
            //var l = sol.LargestTimeFromDigits3(new int[] {1, 2, 4, 3});

            // sol.NumArray(new int[] { 1, 2, 3, 4 });
            //var e = sol.MajorityElement2(new int[] { 3,2,3});



            //var root1 = new TreeNode(1);
            //var root2 = new TreeNode(2);

            //var ls = sol.LeafSimilar2(root1, root2);



            // var r = sol.RemoveKdigits("10200", 1);




            //var l = new ListNode(7);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(4);
            //l.next.next.next = new ListNode(3);

            //var l2 = new ListNode(5);
            //l2.next = new ListNode(6);
            //l2.next.next = new ListNode(4);

            //var a = sol.AddTwoNumbers7(l, l2);

            //  var c = sol.CompareVersion("7.5.2.4", "7.5.3");



            // var root1 = new TreeNode(1);
            // var root2 = new TreeNode(2);

            //  var ls = sol.LeafSimilar3(root1, root2);



            //var s = new MyStack();
            //s.Push(1);
            //s.Push(2);
            //var p = s.Peek();
            //var pop = s.Pop();
            //s.Push(3);
            //var pop2 = s.Pop();
            //s.Push(4);
            ////var ie = s.IsEmpty();

            // var s = sol.MaxSubArray2(new int[] { -2, 1, -3, 4, -1, 2, 1, -5, 4 });


            //var l = new ListNode(1);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(3);
            //l.next.next.next = new ListNode(4);
            //l.next.next.next.next = new ListNode(5);
            //var oel = sol.OddEvenList(l);


            //  var a = new int[][] { new int[2] { 1, 2 }, new int[3] { 1, 2, 3} };

            //  var fcn = sol.FindCircleNum(new int[][] { 
            //  new int[]{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
            //  new int[] {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 }
            //, new int[] {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
            //, new int[] {0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
            //  new int[] {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
            //  new int[] {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            //  new int[] {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
            //  new int[] {0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0}
            //, new int[] {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0}, 
            //  new int[] {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
            //  new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
            //  new int[] {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
            //  new int[] {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
            //  new int[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
            //  new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }});


            //var l = new ListNode(7);
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(4);
            //l.next.next.next = new ListNode(3);

            //var l2 = new ListNode(5);
            //l2.next = new ListNode(6);
            //l2.next.next = new ListNode(4);

            //var io = sol.IsOneEditDistance("ab", "ac");
            // var r = sol.ReverseOnlyLetters("a-bC-dEf-ghIj");

            //var q = new MyCircularQueueListNode(3);
            //var r = q.EnQueue(2);
            //var a1 = q.Rear();
            //var a2 = q.Front();
            //var a3 = q.DeQueue();


            //var root = new TreeNode(1);
            //root.left = new TreeNode(2);
            //root.right = new TreeNode(3);

            //root.left.left = new TreeNode(4);
            //root.left.right = new TreeNode(5);
            //root.right.right = new TreeNode(6);

            //root.left.left.left = new TreeNode(7);
            //root.right.right.right = new TreeNode(8);
            //var s = sol.DeepestLeavesSum(root);





            //Console.WriteLine(sol.wildcard_match("aaab", "aab")); //true;
            //Console.WriteLine(sol.wildcard_match("aab", "aaab")); // False
            //Console.ReadKey();
            // Console.WriteLine(wildcard_match("hello world", ".ello"));
            // Console.WriteLine(wildcard_match("hello world", "..llo.wor"));
            // Console.WriteLine(wildcard_match("hello world", "or.."));
            // Console.WriteLine(wildcard_match("hello world", "or..."));
            // Console.WriteLine(wildcard_match("hello world", "...llo"));   


            //var m = sol.MaxRepOpt2("abcaa");


            //  var cc = sol.CoinChange(new int[] { 2, 1, 5 }, 4);



            // var e = sol.Exist(new char[][] { new char[] { 'A', 'B', 'C', 'E' }, new char[] { 'S', 'F', 'C', 'S' }, new char[] { 'A', 'D', 'E', 'E' } }, "ABCCED");


            // var c = sol.Check(new int[] { 3, 4, 5, 1, 2});

            //var ln = sol.LuckyNumbers(new int[][] { new int[] { 1, 10, 4, 2 }, new int[] { 9, 3, 8, 7 }, new int[] { 15, 16, 17, 12 } });


            //var matrix = new int[][] { new int[] { 0, 1, 2, 0 }, new int[] { 3, 4, 5, 2 }, new int[] { 1, 3, 1, 5 } };
            //sol.SetZeroes(matrix);
            //var ai = sol.MyAtoi3("+"); // "20000000000000000000");

            // var up = sol.UniquePathsIII(new int[][] { new int[] { 1, 0, 0, 0 }, new int[] { 0, 0, 0, 0 }, new int[] { 0, 0, 2, -1 } });



            //var pi = new PeekingIterator(new List<int> { 1, 2, 3 });

            //var a = pi.Next();
            //var b = pi.Peek();
            //var c = pi.Next();
            //var d = pi.Next();
            //var e = pi.HasNext();



            // var si = sol.FindSpecialInteger(new int[] { 1, 2, 2, 6, 6, 6, 6, 7, 10 });

            // int[] d = new int[] { 0, 1, 2, Int32.MaxValue }; //, Int32.MaxValue};
            // var hd = sol.HasDupes(d);


            //var numsubmatrices = sol.NumSubmat(new int[][] { new int[] { 1, 0, 1 }, new int[] { 1, 1, 0 }, new int[] { 1, 1, 0}});
            //  var su = sol.SumOfUnique(new int[] { 1, 2, 3, 2 });
            //var siw = sol.SwimInWater(new int[][] { new int[] { 0, 2 }, new int[] { 1, 3 } });
            //   var mcw = sol.MostCommonWord("Bob. hIt, baLl", new string[] { "bob", "hit" });

            //var us = new UndergroundSystem();
            //us.checkIn(596854, "EQH524YN", 13);
            //us.checkIn(29725, "Y1A2ROGU", 17);
            //us.checkOut(596854, "8AYN1B7O", 115);
            //us.checkIn(579716, "EQH524YN", 145);
            //us.checkOut(579716, "8AYN1B7O", 199);
            //us.checkOut(29725, "8AYN1B7O", 295);
            //us.checkIn(939079, "16MTS56Z", 371);
            //var at1 = us.getAverageTime("EQH524YN","8AYN1B7O");
            //var at2 = us.getAverageTime("Y1A2ROGU", "8AYN1B7O");
            //us.checkIn(697035, "EQH524YN", 442);
            //us.checkIn(90668, "Y1A2ROGU", 508);
            //var at3 = us.getAverageTime("EQH524YN", "8AYN1B7O");


            // var dn = sol.FindDisappearedNumbers(new int[] { 4, 3, 2, 7, 8, 2, 3, 1 });

            //var s = sol.CustomSortString2("cba", "abcd");

            //   var sk = sol.SortKMessedArray(new int[] { 1, 4, 5, 2, 3, 7, 8, 6, 10, 9 }, 2);


            //var a = "a";
            //var b = "b";

            //var r1 = a == b;

            //var r2 = a.Equals(b);
            //var cs = sol.CombinationSum(new int[]{ 2, 3, 6, 7 }, 7);
            // var nr = sol.NumRollsToTarget(2, 6, 7);
            //var sm = sol.sockMerchant(10, new int[] { 1, 1, 3, 1, 2, 1, 3, 3, 3, 3 });
            //var ms = sol.minimumSwaps(new int[] { 4, 3, 1, 2 });


            //var l = new ListNode(2);
            //l.next = new ListNode(5);
            //l.next.next = new ListNode(3);
            //l.next.next.next = new ListNode(4);

            //l.next.next.next.next = new ListNode(6);
            //l.next.next.next.next.next = new ListNode(2);
            //  l.next.next.next.next.next.next = new ListNode(2);





            //var sp = sol.SwapPairs2(l);
            // sol.minimumBribes(new int[] { 2, 1, 5, 3, 4 });

            //  var fd = sol.foo(250, new List<int>() { 100, 180, 40, 120, 10 });

            //  var dc = sol.doesCircleExist(new List<string>() {  "GLGLGLGL" });


            //  var cs = sol.connectedSum(4, new List<string>() {"8 1","5 8","7 3","8 6"});

            //  var l = new ListNode(1);
            // l.next = new ListNode(0);
            //l.next.next = new ListNode(9);
            //l.next.next.next = new ListNode(9);


            //var l2 = new ListNode(7);
            //l2.next = new ListNode(3);
            //l2.next.next = new ListNode(2);
            //var ai = sol.add_integers(l, l2);

            //var mp2 = sol.MaxProfit2(new int[] { 7, 1,5,3,6,4 });

            //var pes = sol.ProductExceptSelf3()
            // var mcw2 = sol.MostCommonWord2("Bob hit a ball, the hit BALL flew far after it was hit.", new string[] { "hit" });
            //  var gmn = sol.getMissingNo(new int[] { 1, 2, 4 }, 3);
            // sol.test();


            //var root = new TreeNode(4);
            //root.left = new TreeNode(7);
            //root.right = new TreeNode(9);
            //root.left.left = new TreeNode(10);
            //root.left.right = new TreeNode(2);
            //root.right.right = new TreeNode(6);
            //root.left.right.right = new TreeNode(6);
            //root.left.right.right.left = new TreeNode(2);

            //var ael = sol.getavgeachlevel(root);

            //  var pt = sol.Generate(5);
            //  var css = sol.CustomSortString3("cba", "abcd");

            // var cc = sol.CountCharacters(new string[] { "cat", "bt", "hat", "tree" }, "atach");

            //var ilpn = sol.IsLongPressedName("leelee", "lleeelee");
            //   var ilpn = sol.IsLongPressedName("saeed", "ssaaedd");

            // var cc = sol.CommonChars2(new string[] { "bella", "label", "roller" });
            //  var dn = sol.FindDisappearedNumbers2(new int[] { 4, 3, 2, 7, 8, 2, 3, 1 });


            //  var sn = sol.SingleNumber(new int[] { 4, 1, 2, 1, 2 });
            //  var zeroed = new int[] { 1, 10, 20, 59, 0, 3, 0, 4, 0, 88 };
            //  sol.move_zeros_to_left(zeroed);


            //var root = new TreeNode(100);
            //root.left = new TreeNode(50);
            //root.right = new TreeNode(200);
            //root.left.left = new TreeNode(25);
            //root.left.right = new TreeNode(75);
            //root.right.right = new TreeNode(350);


            //sol.LevelOrderTraversal(root);

            // var p = sol.Power(2, -2);
            //   var sets = new List<int[]>();
            //   sol.GetAllSubSets(new int[] { 8, 13, 3, 22, 17, 39, 87, 45, 36 }, sets);

            //*********************************************************************************************************************
            //var two = new GraphNode(2);
            //var three = new GraphNode(3);
            //var four = new GraphNode(4);


            //var one = new GraphNode(1, new List<GraphNode>() { two, four});
            //two.neighbors = new List<GraphNode>(){ one, three };
            //three.neighbors = new List<GraphNode>() { two, four };
            //four.neighbors = new List<GraphNode>() { one, three };

            //var cloned = sol.CloneGraph(one);



            // var sr = sol.SearchRange(new int[] { 2, 2 }, 3); // { 5, 7, 7, 8, 8, 10 }, 8);
            // var s = sol.Search2(new int[] { 4, 5, 6, 7, 0, 1, 2 }, 3);
            //sol.Rotate(new int[][] { new int[] { 5, 1, 9, 11 }, new int[] { 2, 4, 8, 10 }, new int[] { 13, 3, 6, 7 }, new int[] { 15, 14, 12, 16 } }); 
            //  var nw = sol.numberOfWays2(new int[] { 1, 5, 3, 3, 3 }, 6); // 7, 9, 5, 3,3 }, 6);
            //  var rc = sol.rotationalCipher("All-convoYs-9-be:Alert1.", 4);
            //Expected:   "Epp-gsrzsCw-3-fi:Epivx5.";

            //var l = new ListNode(1); 
            //l.next = new ListNode(2);
            //l.next.next = new ListNode(3);
            //l.next.next.next = new ListNode(4);
            // var r = sol.ReverseList(l);
            //

            // var cgec = sol.canGetExactChange(94, new int[] { 5, 10, 25, 100, 200 });

            // var cgec = sol.canGetExactChange(75, new int[] { 4, 17, 29 });


            //var people = new Person[]
            //{
            //    new Person()
            //    {
            //        Name = "a",
            //        Born = 2000,
            //        Death = 2010
            //    },

            //      new Person()
            //    {
            //        Name = "a",
            //        Born = 1975,
            //        Death = 2005
            //    },

            //        new Person()
            //    {
            //        Name = "a",
            //        Born = 1975,
            //        Death = 2003
            //    },

            //          new Person()
            //    {
            //        Name = "a",
            //        Born = 1803,
            //        Death = 1809
            //    },

            //      new Person()
            //    {
            //        Name = "a",
            //        Born = 1750,
            //        Death = 1869
            //    },


            //      new Person()
            //    {
            //        Name = "a",
            //        Born = 1840,
            //        Death = 1935
            //    },
            //      new Person()
            //    {
            //        Name = "a",
            //        Born = 1803,
            //        Death = 1921
            //    },

            //      new Person()
            //    {
            //        Name = "a",
            //        Born = 1894,
            //        Death = 1921
            //    },


            //};

            //var maxpop = sol.FindMaxPopulation(people);


            //var root = new TreeNode(8);
            //root.left = new TreeNode(3);
            //root.right = new TreeNode(10);
            //root.left.left = new TreeNode(1);
            //root.left.right = new TreeNode(6);
            //root.right.right = new TreeNode(14);
            //root.left.right.left = new TreeNode(4);
            //root.left.right.right = new TreeNode(7);
            //root.right.right.left = new TreeNode(13);
            //var visible = sol.VisibleNodes(root);


            //var s = sol.matchingPairs("", "");


            // var ml = sol.MinWindowNotMine("dcbefebce", "fd");


            // ml = sol.MinWindowNotMine("dcbefebbacbfeb", "bbe");


            //  ml = sol.MinWindowNotMine("abc", "ac");

            // var fm = sol.findMedian(new int[] {5, 15, 1, 3});


            // var total = sol.getTotalTime(new int[] { 4, 2, 1, 3 });
            //var ma = sol.findMinArray(new int[] {5, 3, 1}, 2);

            var ma = sol.findMinArray(new int[] {8, 9, 11, 2, 1}, 3);
            


        }

       
    }




    class Solution
    {

        //Time:  O(N Log N)  -  Space:  O(N)  new array
        public int minOverallAwkwardness(int[] arr)
        {

            Array.Sort(arr);   //Log N
            var newarr = new int[arr.Length];
            var l = 0;
            var r = arr.Length - 1;
            var i = 0;
            while (l < r)    //N
            {
                newarr[l++] = arr[i++];
                newarr[r--] = arr[i++];

            }


            var diff = 0;
            for (var j = 0; j < newarr.Length; j++)   //N
            {
                if (j < newarr.Length - 1)
                    diff = Math.Max(diff, Math.Abs(newarr[j] - newarr[j + 1]));
                else
                    diff = Math.Max(diff, Math.Abs(newarr[j] - newarr[0]));
            }

            return diff;
        }
    }

    public  int[] findMinArray(int[] arr, int k)
        {
            var len = arr.Length;
            var pos = 0;
            for (var i = 0; i < len - 1 && k > 0; i++)
            {
                pos = i;
                for (var j = i + 1; j < len; j++)
                {
                    if (j - i > k)
                        break;  
                    if (arr[j] < arr[pos])
                        pos = j;

                    Console.WriteLine("pos=" + pos);
                }

                //Swap elements if smaller ones found
                for (var l = pos; l > i; l--)
                {
                    Console.WriteLine("BEFORE swap: arr[l-1]: " + arr[l - 1] + " arr[l]: " + arr[l]);
                    var temp = arr[l];
                    arr[l] = arr[l - 1];
                    arr[l - 1] = temp;
                    Console.WriteLine("After swap: arr[l-1]: " + arr[l - 1] + " arr[l]: " + arr[l]);

                }
                k -= pos - i;
            }
            return arr;
        }



        public  int getTotalTime(int[] arr)
        {

            MaxHeap heap = new MaxHeap(arr.Length);
            
            var total = 0;
            var arrlst = arr.ToList();

            for (var i = 0; i < arr.Length; i++)
            {
                heap.Add(arr[i]);
            }

            while (heap.Count() > 1)
            {

                var a = heap.Pop();
                var b = heap.Pop();
                total += a + b;
                heap.Add(a + b);

            }

           

            return total;
        }


        public int[] findMedian(int[] arr)
        {

          
            var output = new int[arr.Length];
            var median = 0;
            for (var i = 0; i < arr.Length; i++)
            {
                if (i % 2 == 0)
                {
                    median = arr.Take(i + 1).OrderBy(x => x).Skip(i / 2).Take(1).SingleOrDefault();
                }
                else
                {
                    median = arr.Take(i + 1).OrderBy(x => x).Skip((i + 1) / 2 - 1).Take(2).Sum() / 2;
                }

                output[i] = median;
            }
            return output;

        }

        public  int maxCandies(int[] arr, int k)
        {
            // Write your code here
            //Create a  max heap (priority queue)  and use instead of max.  ??  Try it out
            var candies = 0;

            while (k > 0)
            {
                var max = arr.Max();
                candies += max;
                var index = Array.IndexOf(arr, max);
                max /= 2;
                arr[index] = max;
                k--;
            }
            return candies;

        }







        public string MinWindow(string s, string t)
        {


            var dicts = new Dictionary<char, int>();
            var dictt = new Dictionary<char, int>();


            for (var i = 0; i < t.Length; i++)
            {
                if (!dictt.ContainsKey(t[i]))
                    dictt.Add(t[i], 1);
                else
                    dictt[t[i]]++;
            }
            var minlen = s.Length;
            var minlenstr = "";
            var len = s.Length;
            var l = 0;
            var r = 0;
            var found = false;

            while (l < len && r < len)
            {

                if (!found)
                {

                    if (dictt.ContainsKey(s[r]))
                    {
                        var val = 0;
                        if (dicts.TryGetValue(s[r], out val))
                            dicts[s[r]]++;
                        else
                            dicts.Add(s[r], 1);
                    }


                    if (CompKeys(dicts, dictt))
                    {

                        found = true;
                    }
                    else
                        r++;
                    if (r == len)
                        break;

                }
                if (found)
                {
                    if ( (r - l + 1) < minlen || (r - l + 1) == len)
                    {
                        minlen = r - l + 1;
                        minlenstr = s.Substring(l, r - l + 1);
                    }
                    var valtoremove = 0;
                    if (dicts.TryGetValue(s[l], out valtoremove))
                    {
                        if (valtoremove > 1)
                            dicts[s[l]]--;
                        else
                            dicts.Remove(s[l]);
                    }
                    l++;
                    if (!CompKeys(dicts, dictt))
                    {
                        found = false;
                        r++;
                    }
                }

            }

            return minlenstr;



        }






            public  int minLengthSubstring(String s, String t)  // Facebook Portal
        {

            var dicts = new Dictionary<char, int>();
            var dictt = new Dictionary<char, int>();

        


            for (var i = 0; i < t.Length; i++)
            {
                if (!dictt.ContainsKey(t[i]))
                    dictt.Add(t[i], 1);
                else
                    dictt[t[i]]++;
            }
            var minlen = s.Length;
            var len = s.Length;
            var l = 0;
            var r = 0;
            var found = false;

            while (l < len && r < len)
            {

                if (!found)
                {

                    if (dictt.ContainsKey(s[r]))
                    {
                        var val = 0;
                        if (dicts.TryGetValue(s[r], out val))
                            dicts[s[r]]++;
                        else
                            dicts.Add(s[r], 1);
                    }
                    
                   
                    if (CompKeys(dicts, dictt))
                    {

                        found = true;
                    }
                    else
                        r++;
                    if (r == len)
                        break;

                }
                if (found)
                {
                    minlen = Math.Min(minlen, r - l + 1);
                    var valtoremove = 0;
                    if (dicts.TryGetValue(s[l], out valtoremove))
                    {
                        if (valtoremove > 1)
                            dicts[s[l]]--;
                        else
                            dicts.Remove(s[l]);
                    }
                    l++;
                    if (!CompKeys(dicts, dictt))
                    {
                        found = false;
                        r++;
                    }
                }

            }

            return minlen;

        }

        public bool CompKeys(Dictionary<char, int> dicts, Dictionary<char, int> dictt)
        {
            if (dicts.Count != dictt.Count)
                return false;

            foreach (var pair in dictt)
            {
                var val = 0;
                if (dicts.TryGetValue(pair.Key, out val))
                {
                    if (val < pair.Value)
                        return false;
                }
                else
                    return false;
            }
            return true;
        }



        public int matchingPairs(string s, string t)
        {

            var dicts = new Dictionary<char, int>() { { 'b', 2 }, { 'e', 1 } };
            var dictt = new Dictionary<char, int>() { { 'b', 3 }, { 'e', 1 } };

            var diff = dicts.Except(dictt);

            var sc = dicts.Count();
            var tc = dictt.Count();

            var ss = diff.Count();


            var len = s.Length;
            if (s == t)
            {
                return s.Length - 2;
            }

            var unmatchs = new HashSet<int>();
            var unmatcht = new HashSet<int>();


            var matched = 0;

            for (var i = 0; i < s.Length; i++)
            {
                if (s[i] == t[i])
                    matched++;
                else
                {
                    unmatchs.Add(s[i]);
                    unmatcht.Add(t[i]);
                }
            }

            var dupeunmatched = unmatchs.Intersect(unmatcht);

            var dupescount = dupeunmatched.Count();
            if (dupescount >= 2)
            {
                matched += 2;
            }
            else if (dupescount == 1)
            {
                matched++;
            }
            else if (len - matched == 0)
                matched -= 2;
            else if (len - matched == 1)
                matched--;


            // Write your code here
            return matched;
        }


        static int[] countOfNodes(Node root, List<Query> queries, String s)
        {

            var output = new List<int>();

            for (var i = 0; i < queries.Count; i++)
            {
                var count = 0;
                for (var j = queries[i].u - 1; j < s.Length; j++)
                {
                    if (s[j] == queries[i].c)
                    {
                        count++;
                    }
                }
                output.Add(count);


            }

            return output.ToArray();
        }






    public int VisibleNodes(TreeNode root) //should be a treenode with right and left.
        {
            if (root == null)
                return 0;
            var leftdepth = VisibleNodes(root.left);
            var rightdepth = VisibleNodes(root.right);
            if (leftdepth > rightdepth)
                return leftdepth + 1;
            else
                return rightdepth + 1;
        }



        public int FindMaxPopulation(Person[] people)
        {
           // var sorted = people.OrderBy(p => p.Born).ThenBy(p => p.Death).ToList();
            var alive = 0;
            var max = 0;
            var year = 0;


            var orderedbd = CombineDeathBirths(people);

            for (var i = 0; i < orderedbd.Count; i++)
            {
                if (orderedbd[i][1] == 1)
                {
                    alive++;
                    if (alive > max)
                    {
                        max = alive;
                        year = orderedbd[i][0];
                    }
                }
                else
                    alive--;
                    

            }



            return year;




        }


        private List<int[]> CombineDeathBirths(Person[] people)
        {

            var results = new List<int[]>();



            for (var i = 0; i < people.Length; i++)
            {
                results.Add(
                    new int[2]
                    {
                        people[i].Born,
                        1
                    });

                results.Add(
                    new int[2]
                    {
                        people[i].Death+1,
                        0
                    });

            }

            return results.OrderBy(r => r[0]).ToList();


        }
        
        
        public int[] findMaxProduct(int[] arr)
        {
            var output = new int[arr.Length];
            for (var i = 0; i < arr.Length; i++)
            {
                output[i] = i < 2 ? -1 : arr[i] * arr[i - 1] * arr[i - 2];
            }
            // Write your code here
            return output;
        }

        public int[] findSignatureCounts(int[] arr)
        {

           // var pq = new PriorityQueue<int, int>();

            var len = arr.Length;
            var signatures = new int[len];
            var numsignatures = 1;
            Array.Fill(signatures, numsignatures);
            numsignatures++;
            var yearbooks = arr.ToArray();
            var sortedyearbooks = arr.ToArray();
            Array.Sort(sortedyearbooks);

            while (!IsSorted(yearbooks))
            {
                Array.Fill(signatures, numsignatures++);
                for (var i = 0; i < len; i++)
                {
                    yearbooks[arr[i] - 1] = arr[i];
                }

            }


            return signatures;
        }

        public bool IsSorted(int[] arr)
        {
            for (int i = 1; i < arr.Length; i++)
            {
                if (arr[i - 1] > arr[i])
                {
                    return false;
                }
            }
            return true;
        }





        private int[] _denominations;
        public bool canGetExactChange(int targetMoney, int[] denominations)
        {
            _denominations = denominations;
            return doDenom(targetMoney, 0);
        }

        private bool doDenom(int money, int index)
        {
            if (money == 0)
                return true;
            if (index == _denominations.Length)
                return false;

            bool include = false;
            bool exclude = false;

           
            if (money >= _denominations[index])
                include = doDenom(money - _denominations[index], index);

            exclude = doDenom(money, index + 1);

            return include || exclude;
        }


        private static String findEncryptedWord(String s)
        {

            if (String.IsNullOrEmpty(s))
                return "";

            var midx = (s.Length - 1) / 2;
            var m = s[midx];

            return "";
        }



        public bool isBalanced(string s)
        {
            var stack = new Stack<char>();


            for (var i = 0; i < s.Length; i++)
            {
                var c = s[i];
                switch (c)
                {
                    case '(':
                        stack.Push(c);
                        break;

                    case ')':
                        if (stack.Count == 0 || (stack.Count > 0 && stack.Pop() != '('))
                            return false;
                        break;


                    case '{':
                        stack.Push(c);
                        break;
                    case '}':
                        if (stack.Count == 0 || (stack.Count > 0 && stack.Pop() != '{'))
                            return false;
                        break;

                    case '[':
                        stack.Push(c);
                        break;
                    case ']':
                        if (stack.Count == 0 || (stack.Count > 0 && stack.Pop() != '['))
                            return false;
                        break;

                    default:
                        break;
                }


            }


            return true;
        }


        public int[] findPositions(int[] arr, int x)
        {


            var results = new List<int>();
            var newlist = new List<int[]>();
            for (var i = 0; i < arr.Length; i++)
            {
                newlist.Add(new int[] { i + 1, arr[i] });
            }

            for (var i = 0; i < x; i++)
            {
                var c = x;
                var max = new int[2];
                var templist = new List<int[]>();
                while (newlist.Count > 0 && c > 0)
                {
                    var r = newlist[0];

                    newlist.RemoveAt(0);
                    if (r[1] > max[1])
                        max = r;

                    templist.Add((r[1] - 1 >= 0) ? new int[] { r[0], r[1] - 1 } : new int[] { r[0], 0 });

                    c--;
                }
                if (max[0] == 0)
                    max[0] = templist[0][0];

                templist.Remove(templist.Single(t => t[0] == max[0]));

                results.Add(max[0]);
                newlist.AddRange(templist);
                foreach (var nl in newlist)
                {
                    Console.WriteLine(nl[0]);
                }
                Console.WriteLine("*******");
            }


            return results.ToArray();
        }






        public ListNode ReverseList2(ListNode head)
        {
            ListNode prev = null;
            while (head != null)
            {
                (head.next, prev, head)  = (prev, head, head.next);
            }
            return prev;
        }


        public static Node reverse(Node head)
        {
            var node = head;
            var odd = head;
            while (node != null)
            {
                if (node.next != null && node.next.val % 2 == 0)
                {
                    var stack = new Stack<int>();
                    while (node.next != null && node.next.val % 2 == 0)
                    {
                        stack.Push(node.next.val);
                        node = node.next;
                    }
                    node = node.next;
                    while (stack.Count > 0)
                    {
                        odd.next.val = stack.Pop();
                        odd = odd.next;
                    }
                    odd = odd.next;
                }
                else
                    node = node.next;

            }
            return head;
        }


        public string rotationalCipher(String input, int rotationFactor)
        {

            var sb = new StringBuilder();
            var rf = 0;
            char output;
            for (var i = 0; i < input.Length; i++)
            {
                if (input[i] <= 'z' && input[i] >= 'a')
                {
                    rf = rotationFactor % 26;
                    if (input[i] + rf > 'z')
                        output = (char)(input[i] + rf - 26);
                    else
                        output = (char)(input[i] + rf);
                    
                  
                    sb.Append(output);

                }
                else if (input[i] >= 'A' && input[i] <= 'Z')
                {
                    rf = rotationFactor % 26;
                    
                    if (input[i] + rf > 'Z')
                        output = (char)(input[i] + rf - 26);
                    else
                        output = (char)(input[i] + rf);

                  
                    sb.Append(output);
                }
                else if (input[i] <= '9' && input[i] >= '0')
                {
                    rf = rotationFactor % 10;
                  
                    if (input[i] + rf > '9')
                        output = (char)(input[i] + rf - 10);
                    else
                        output = (char)(input[i] + rf);
                    sb.Append(output);

                }
                else
                    sb.Append(input[i]);

            }

            return sb.ToString();
        


    }



        //Get this working and learn it
        //int[] countSubarrays(int[] arr)
        //{
        //    // Write your code here
        //    Stack<int> s = new Stack<int>();
        //    int[] L = new int[arr.Length];
        //    L[0] = 1;
        //    s.Push(0);
        //    for (int i = 1; i < arr.Length; i++)
        //    {
        //        while (!s.isEmpty() && arr[s.peek()] < arr[i]) s.pop();
        //        if (s.isEmpty()) L[i] = i + 1;
        //        else L[i] = i - s.peek();
        //        s.push(i);
        //    }
        //    int[] R = new int[arr.length];
        //    R[arr.length - 1] = L[arr.length - 1];
        //    s.clear();
        //    s.push(arr.length - 1);
        //    for (int i = arr.length - 2; i >= 0; i--)
        //    {
        //        while (!s.isEmpty() && arr[s.peek()] < arr[i]) s.pop();
        //        if (s.isEmpty()) R[i] = (arr.length - i) + L[i] - 1;
        //        else R[i] = (s.peek() - i) + L[i] - 1;
        //        s.push(i);
        //    }
        //    return R;
        //}




        public int MaxSubArray3(int[] nums)
        {
            var max = nums[0];
            for (var i = 1; i < nums.Length; i++)
            {
                if (nums[i - 1] > 0)
                    nums[i] += nums[i - 1];
                max = Math.Max(max, nums[i]);

            }
            return max;

        }


        //O(n2) - not good
        private static int[] countSubarrays(int[] arr)
        {
            var result = new int[arr.Length];
            var forward = 0;
            var backward = 0;
            var count = 0;

            for (var i = 0; i < arr.Length; i++)
            {

                count = 1;  //all elements have an array of themselves;
                backward = i - 1;
                while (backward >= 0 && arr[backward] < arr[i])
                {
                    count++;
                    backward--;
                }

                forward = i + 1;
                while (forward < arr.Length && arr[forward] < arr[i])
                {
                    count++;
                    forward++;
                }


                result[i] = count;



            }


            return result;






        }
   



    internal int numberOfWays2(int[] arr, int k)
        {
            var n = arr.Length;
            var sum = k;
            Dictionary<int, int> hm
          = new Dictionary<int, int>();
 
        
        for (int i = 0; i<n; i++) {

          
                if (!hm.ContainsKey(arr[i]))
                {
                    hm[arr[i]] = 1;
                }
                else
                    hm[arr[i]]++;
          
                }
        int twice_count = 0;

        // iterate through each element and
        // increment the count (Notice that
        // every pair is counted twice)
        for (int i = 0; i < n; i++)
        {
            int val = 0;
            if (hm.TryGetValue(sum - arr[i], out val)) 
            {
                    twice_count += val; // ValueTuple; ValueTuple; // hm[sum - arr[i]];
            }

            // if (arr[i], arr[i]) pair satisfies
            // the condition, then we need to ensure
            // that the count is decreased by one
            // such that the (arr[i], arr[i])
            // pair is not considered
            if (sum - arr[i] == arr[i])
            {
                twice_count--;
            }
        }

// return the half of twice_count
return twice_count / 2;
}

internal int numberOfWays(int[] arr, int k)
        {
            // Write your code here
            var count = 0;
            for (var i = 0; i < arr.Length - 1; i++)
                for (var j = i + 1; j < arr.Length; j++)
                {
                    if (arr[i] + arr[j] == k)
                        count++;
                }
            Console.WriteLine(count);
            return count;
            
        }




        public void Rotate(int[][] matrix)
        {
            var len = matrix.Length;
            for (var i = 0; i < len; i++)
            {
                for (var j = i; j < len; j++)
                {
                    if (i != j)
                    (matrix[i][j], matrix[j][i]) = (matrix[j][i], matrix[i][j]);
                }




            }

            for (var i = 0; i < len; i++)
            {
                for (var j = 0; j < (len / 2); j++)
                {
                    (matrix[i][j], matrix[i][len - j - 1]) = (matrix[i][len - j - 1], matrix[i][j]);


                }
            }
            
        }



        public ListNode AddTwoNumbers9(ListNode l1, ListNode l2)
        {

            var carry = 0;
            ListNode newnode = new ListNode(-1);
            var head = newnode;
            while (l1 != null || l2 != null || carry == 1)
            {
                var sum = (l1?.val ?? 0) + (l2?.val ?? 0) + carry;
                carry = sum / 10;
                sum %= 10;

                l1 = l1?.next;
                l2 = l2?.next;

                if (newnode.val == -1)
                    newnode.val = sum;
                else
                {
                    newnode.next = new ListNode(sum);
                    newnode = newnode.next;
                }
            }

            return head;


        }



        public int UniquePaths(int m, int n)
        {

            var dp = new int[m, n];
            for (var i = 0; i < m; i++)
            {
                for (var j = 0; j < n; j++)
                {
                    if (i == 0 || j == 0)
                    {
                        dp[i, j] = 1;
                    }
                    else
                        dp[i, j] = dp[i - 1, j] + dp[i, j - 1];
                }
            }

            return dp[m - 1, n - 1];
        }


        public int Search2(int[] nums, int target)
        {
            var start = 0;
            var len = nums.Length;
            var end = len - 1;
            var mid = start + (end - start) / 2;
            while (start <= end)
            {
                if (nums[mid] == target)
                    return mid;
                else if (nums[mid] <= nums[end])
                { 
                    if (target >= nums[mid] && target <= nums[end])
                    
                        start = mid + 1;

                    
                    else
                        end = mid - 1;
                }
                else
                {
                    if (target >= nums[start]
                    && target <= nums[mid])
                    
                        end = mid - 1;

                    
                    else
                        start = mid + 1;
                }

                mid = start + (end - start) / 2;
            }
            return -1;


        }



        public int[] SearchRange(int[] nums, int target)
        {
            var low = 0;
            var high = nums.Length - 1;
            var mid = high / 2;

            var results = new int[2];

            while (low <= high)
            {
                if (nums[mid] < target)
                    low = mid + 1;

                if (nums[mid] >= target)
                    high = mid - 1;
                mid = low +  ((high - low) / 2);
            }
            if (low > nums.Length -1 || nums[low] != target)
                return new int[] { -1, -1 };
            else
                results[0] = low;

            high = nums.Length - 1;
            mid = low + ((high - low) / 2);

            while (low <= high)
            {
                if (nums[mid] <= target)
                    low = mid + 1;

                if (nums[mid] > target)
                    high = mid - 1;
                mid = low + ((high - low) / 2);

            }
            if (high > nums.Length -1 || nums[high] != target)
                return new int[] { -1, -1 };
            else
                results[1] = high;
            return results;


        }








        //https://leetcode.com/problems/clone-graph/


        Dictionary<int, GraphNode> dict2 = new Dictionary<int, GraphNode>();
        public GraphNode CloneGraph(GraphNode node)
        {
            if (dict2.ContainsKey(node.val))
                return dict2[node.val];
            var newnode = new GraphNode(node.val);
            dict2.Add(newnode.val, newnode);
            foreach (var n in node.neighbors)
                newnode.neighbors.Add(CloneGraph(n));
            return newnode;
        }


        public GraphNode CloneGraph2(GraphNode node)
        {
            //var table = new Hashtable();
            //table.
            var hash = new HashSet<GraphNode>();
            var root = new GraphNode(node.val);
            
            
            DoClone(node, hash);
            return root;
        }


        private void DoClone(GraphNode node, HashSet<GraphNode> visited)
        {
            if (node == null)
                return;

            var actual = new GraphNode();
            if (!visited.TryGetValue(node, out actual))
            {
                var newnode = new GraphNode(node.val);
                newnode.neighbors = new List<GraphNode>(node.neighbors);
                visited.Add(newnode);
            }
            
            foreach (var v in node.neighbors)
            {
                if (v != null)
                    DoClone(v, visited);
            }
        }


        //Do integer break https://leetcode.com/problems/integer-break/
        public int IntegerBreak(int n)
        {

            if (n <= 2)
                return 1;
            else if (n == 3)
                return 2;

            var threes = n / 3;
            var twos = 0;
            if (n % 3 == 1)
            {
                threes--;
                twos = 2;
            }
            else if (n % 3 == 2)
            {
                twos = 1;
            }
            var result = (int)(Math.Pow(3, threes) * Math.Pow(2, twos));
            return result;

        }
        //get min heap and priority queue figured out.


        //Create in C#:
        internal void GetAllSubSets(int []v, List<int[]> sets)
        {
            //def get_all_subsets(v, sets):
            var subsets_count = 2 * v.Length;
            for (var i = 0; i < subsets_count; i++)
            {
                // for i in range(0, subsets_count) :
                var st = new int[] { };
                for (var j = 0; j < v.Length; j++)
                {
                    if (GetBit(i, j) == 1)
                    {
                        st.Append(v[j]);
                        sets.Add(st);
                    }
                }
            }

        }

        internal int GetBit(int num, int bit)
        {
            // def get_bit(num, bit):
            var temp = (1 << bit);
            temp = temp & num;
            if (temp == 0)
                return 0;
            return 1;
        }



        internal double Power(double x, int n)
        {
            var negative = false;
                if (n < 0)
            {
                n *= -1;
                negative = true;
            }

            var p =PowerRecurse(x, n);

            return negative ? 1/ p : p;

        }

        private double PowerRecurse(double x, int n)
        {
            if (n == 0)
                return 1;
            else if (n == 1)
                return x;
            
            var p = PowerRecurse(x, n / 2);
            if (n % 2 == 0)
                return p * p;
            else
                return x * p * p;

        }




        internal void LevelOrderTraversal(TreeNode root)
        {
            var currentqueue = new Queue<TreeNode>();
            var nextqueue = new Queue<TreeNode>();

            currentqueue.Enqueue(root);
           // var level = 0;
            

            while (currentqueue.Count > 0)
            {
                var node = currentqueue.Dequeue();
                Console.Write(node.val + " ");

                if (node.left != null)
                    nextqueue.Enqueue(node.left);

                if (node.right != null)
                    nextqueue.Enqueue(node.right);

                if (currentqueue.Count == 0)
                {
                    Console.WriteLine();
                    (nextqueue, currentqueue) = (currentqueue, nextqueue);
                   // level++;
                }

            }

        }



        internal int MaxProfitBestVersion(int[] prices)
        {
            var maxprofit = 0;
            var minprice = 10001; //Or whatever the maximum price could be + 1

            for (var i = 0; i < prices.Length; i++)
            {
                if (prices[i] < minprice)
                    minprice = prices[i];
                else
                    maxprofit = Math.Max(maxprofit, prices[i] - minprice);
            }
            return maxprofit;
        }






        internal void move_zeros_to_left(int[] n)
        {

            //1 10 20 59 0 3 0 4 0 88 --> 0 0 0 1 10 20 59 3 4 88
            //2 pointer
            //write pointer, read pointer, etc... start from end move to start.
            var len = n.Length;
            var write = len - 1;
            var read = len - 1;
            while (read >= 0)
            {
                if (n[read] != 0 )
                {
                    n[write] = n[read];
                    write--;
                }
                read--;
            }

            while (write >=0)
            {
                n[write] = 0;
                write--;
            }

        }

        //do this!!  done
        //public string RemoveKdigits(string num, int k)
        //{
        //    var stack = new Stack<char>();
        //    var len = num.Length;

        //    for (var i = 0; i < len; i++ )
        //    {

        //    }


        //}
        //Fibonacci same thing
        public int ClimbStairsnorecursion(int n)
        {
            if (n <= 2)
                return n;
            var dp = new int[n + 1];

            dp[1] = 1;
            dp[2] = 2;
            for (var i = 3; i <= n; i++)
                dp[i] = dp[i - 1] + dp[i - 2];

            return dp[n];

        }



        public int FindDuplicate(int[] nums)
        {
            Array.Sort(nums);
            for (var i = 0; i < nums.Length - 1; i++)
            {
                if (nums[i] == nums[i + 1])
                    return nums[i];
            }
            return 0;
        }






        public int SingleNumber(int[] nums)
        {
            var singleNumber = 0;
            foreach (var num in nums)
            {
                singleNumber ^= num;
            }
            return singleNumber;
        }



        public IList<int> FindDisappearedNumbers2(int[] nums)
        {
            var result = new List<int>();
            for (var i = 0; i < nums.Length; i++)
            {
                var j = Math.Abs(nums[i]);
                
                nums[j - 1] *= nums[j - 1] < 0 ? nums[j - 1] : nums[j - 1] * -1; // Math.Abs(nums[j - 1]) * -1;
            }

          
            for (var i = 0; i < nums.Length; i++)
            {
                if (nums[i] > 0)
                {
                    result.Add(i + 1);
                }
            }

            return result;
        }




        public void SortColors2(int[] nums)
        {
            var left = 0;
            var right = nums.Length - 1;

            for (var i = 0; i <= right; i++)
            {
                if (nums[i] == 0)
                {
                    (nums[i], nums[left]) = (nums[left], nums[i]);
                    left++;

                }
                else if (nums[i] == 2)
                {
                    (nums[i], nums[right]) = (nums[right], nums[i]);
                    right--;
                    i--;

                }

            }
        }

        public bool CheckRecord(string s)
        {
            var a = 0;
            var l = 0;

            for (var i = 0; i < s.Length; i++)
            {
                if (s[i] == 'L')
                    l++;
                else
                {
                    if (s[i] == 'A')
                    {
                        a++;
                    }
                    l = 0;
                }
                if (a > 1)
                    return false;
                else if (l > 2)
                    return false;
            }
            return true;
        }

        public IList<string> CommonChars2(string[] A)
        {
            var dict = new Dictionary<char, Dictionary<int, int>>();
            var wordnum = 0;
            for (var i = 0; i < A.Length; i++)
            {
                
                for (var j = 0; j < A[i].Length; j++)
                {
                    if (!dict.ContainsKey(A[i][j]))
                        dict.Add(A[i][j], new Dictionary<int, int>() { { wordnum, 1 } });
                    else
                    {
                        if (!dict[A[i][j]].ContainsKey(wordnum))
                            dict[A[i][j]].Add(wordnum, 1);
                        else
                            dict[A[i][j]][wordnum]++;
                    }
                }
                wordnum++;
            }

            var common = new List<string>();
            foreach (var dd in dict)
            {
                if (dd.Value.Count < A.Length)
                    continue;

                var min = dd.Value.Values.Min();
             
                    for(var j = 1; j <= min; j++)
                    {
                        common.Add(dd.Key.ToString());
                    }
            }
            return common;
        }


        public bool IsLongPressedName(string name, string typed)
        {
            if (name.Length > typed.Length)
                return false;
            int i = 0, j = 0;
            for (; i < name.Length; i++)
            {
                if (i < name.Length && j >= typed.Length)
                    return false;
                if (i < name.Length && j < typed.Length && name[i] != typed[j])
                    return false;
                if (i < name.Length - 1 && name[i] == name[i + 1])
                {
                    j++;
                    continue;
                }

                while (j < typed.Length && name[i] == typed[j])
                {
                    j++;
                }

            }

            if (j < typed.Length)
                return false;
            else
                return true;
        }


        public int HeightChecker(int[] heights)
        {
            var count = 0;
            var sorted = new int[heights.Length];
            Array.Copy(heights, sorted, heights.Length);
            Array.Sort(sorted);
            for (var i = 0; i < sorted.Length; i++)
            {
                if (sorted[i] != heights[i])
                    count++;
            }

            return count;
        }

        //public int CountCharacters(string[] words, string chars)
        //{

        //    var good = words.Where(w => w.Any(chars));
        //    var length = 0;
        //    foreach (var g in good)
        //        length += g.Count();
        //    return length;

        //}



        public string CustomSortString3(string S, string T)
        {
            var sb = new StringBuilder();
            var tl = T.ToList();
            for (var i = 0; i < S.Length; i++)
            {

                var foundat = T.IndexOf(S[i]);
                while (foundat > -1)
                {
                    sb.Append(S[i]);
                    T = T.Remove(foundat, 1);
                    foundat = T.IndexOf(S[i]);
                }



            }
            for (var j = 0; j < T.Length; j++)
                sb.Append(T[j]);
            return sb.ToString();
        }






        public IList<IList<int>> Generate(int numRows)
        {
            var result = new List<IList<int>>();
            for (var i = 0; i < numRows; i++)
            {
                IList<int> row = new List<int>();
                for (var j = 0; j <= i; j++)
                {
                   
                    if (j <= 0 || j == i)
                        row.Add(1);
                    else
                    {
                        if (i > 1)
                        {
                            var n = result[i - 1][j - 1] + result[i - 1][j];
                            row.Add(n);
                        }
                    }
                  
                }
                result.Add(row);

            }
            return result;
        }


        //Change it to be more efficient in space  so dictionary<int, int, int>();
        internal List<int> getavgeachlevel(TreeNode root)
        {
            if (root == null)
                return null;
            var dict = new Dictionary<int, Tuple<int, int>>();
            TDFS(root, 0, null);
            List<int> result = new List<int>();
            foreach(var d in dict)
            {
                var avg = 1;// d.Value.Sum() / d.Value.Count;
                result.Add(avg);
            }

            return result;
        }

        private void TDFS(TreeNode node, int level, Dictionary<int, List<int>> dict)
        {
            if (node == null)
                return;

            if (!dict.ContainsKey(level))
            {
                dict[level] = new List<int>(){ node.val};
            }
            else
            { 
                dict[level].Add(node.val);
            }
            TDFS(node.left, level + 1, dict);
            TDFS(node.right, level + 1, dict);


        }

        internal void test()
        {
            HashSet<int> b;
            Hashtable c;
            Dictionary<int, int[]> d = new Dictionary<int, int[]>();
            var e = new int[] {1,2,3 };

            e[0] = 23;

            e[3] = 24;

        }

        internal int getMissingNoSucks(int[] a)
        {
            var len = a.Length;
            Array.Sort(a);
            var missing = 0;
            for (var i = 0; i < len; i++)
                if (a[i] != i + 1)
                    missing = i + 1;

            return missing;
            
        }

        internal int getMissingNo(int[] a, int n)
        {
            var total = (n + 1) * (n + 2) / 2;
            for (var i = 0; i < n; i++) 
                total -= a[i];
           
         
            return total;
        }

            public string MostCommonWord2(string paragraph, string[] banned)
        {
            var clean = paragraph.Replace(",", " ").Replace("!", " ").Replace("?", " ").Replace(";", " ").Replace(".", " ").ToLower();
            var split = clean.Split(' ', StringSplitOptions.RemoveEmptyEntries);

            var dict = new Dictionary<string, int>();
            for (var i = 0; i < split.Length; i++)
            {
                var clword =  split[i].Where(w => char.IsLetterOrDigit(w));
                var word = new string(clword.ToArray());
                if (!banned.Contains(word))
                {
                    if (!dict.ContainsKey(word))
                        dict.Add(word, 1);
                    else
                        dict[word]++;
                }
            }

            var mfw = dict.OrderByDescending(d => d.Value).FirstOrDefault().Key;
            return mfw;
        }

        public int[] ProductExceptSelf3(int[] nums)
        {
            var len = nums.Length;
            var result = new int[len];
            Array.Fill(result, 1);
            var product = 1;
            for (var i = 0; i < len - 1; i++)
            {
                product *= nums[i];
                result[i + 1] *= product;
            }

            product = 1;
            for (var i = len - 1; i > 0; i--)
            {
                product *= nums[i];
                result[i - 1] *= product;
            }


            return result;
        }




        public int MaxProfit2(int[] prices)
        {
            var profit = 0;
            var buy = 10001;
            var len = prices.Length;
            for (var i = 0; i < len; i++)
            {
                if (prices[i] < buy)
                {
                    buy = prices[i]; 
                }
                else
                {
                    profit = Math.Max(profit, prices[i] - buy);
                }


            }

            //var profit = sell - buy;
            return profit;
        }



        internal ListNode add_integers(ListNode integer1, ListNode integer2)
        {
            //TODO: Write - Your - Code
            var newnode = new ListNode(Int32.MinValue);
            var newhead = newnode;
            var carry = 0;
            while (integer1 != null || integer2 != null || carry == 1)
            {
                var sum = (integer1 == null ? 0 : integer1.val) + (integer2 == null ? 0 : integer2.val) + carry;
                carry = sum / 10;
                sum %= 10;
                if (newnode.val == Int32.MinValue)
                {
                    newnode.val = sum;
                }
                else
                {
                    newnode.next = new ListNode(sum);
                    newnode = newnode.next;
                }
                integer1 = integer1?.next;
                integer2 = integer2?.next;

            }
            return newhead;
        }


        internal int find_missing(List<int> input)
        {
            //TODO: Write - Your - Code
            //Collections.sort(input);
            input.Sort();
            for (int i = 0; i < input.Count; i++)
            {
                if (input[i] != i + 1)
                    return i + 1;
            }
            return -1;
        }


        public bool find_sum_of_three(int[] arr, int required_sum)
        {
            // TODO: Write - Your - Code
            Array.Sort(arr);


            
            int len = arr.Length;

            for (int i = 0; i < len - 2; i++)
            {
                int low = i + 1;
                int high = len - 1;
                while (low < high)
                {
                    int sum = arr[i] + arr[low] + arr[high];
                    if (sum == required_sum)
                        return true;
                    else if (sum <= required_sum)
                    {
                        low++;
                    }
                    else
                    {
                        high--;
                    }
                }
            }
            return false;
        }


        internal int connectedSum(int n, List<string> edges)
        {
            var iedges = new List<List<int>>();
            foreach (var edge in edges)
            {
                var nums = edge.Split(' ').Select(x => int.Parse(x)).ToList();
                iedges.Add(nums);

            }

            var counts = new List<int>();
            var sqrts = new List<double>();
            var count = 0;
            bool inlist = false;
            var alledges = new List<int>();
            var dict = new Dictionary<int, int>();
            for (var i = 0; i < iedges.Count; i++)
            {
                if (inlist && !dict.ContainsKey(iedges[i][0]) && !dict.ContainsKey(iedges[i][1]))
                {
                    counts.Add(count);
                    count = 0;
                    inlist = false;
                    foreach (var elem in dict)
                    {
                        alledges.Add(elem.Key);
                    }
                    dict.Clear();
                }
                if (!inlist && !dict.ContainsKey(iedges[i][0]) || !dict.ContainsKey(iedges[i][1]))
                {


                    if (!dict.ContainsKey(iedges[i][0]))
                    { 
                        dict.Add(iedges[i][0], 1);
                        count++;
                    }

                    //}
                    //if (!inlist && !dict.ContainsKey(iedges[i][1]))
                    // {

                    if (!dict.ContainsKey(iedges[i][1]))
                    {
                        dict.Add(iedges[i][1], 1);
                        count++;
                    }
                    inlist = true;

                }
               

                
            }


            foreach (var elem in dict)
            {
                if (!alledges.Contains(elem.Key))
                    alledges.Add(elem.Key);
            }

            if (count > 0)

            {
                counts.Add(count);
            }

            var totals = 0;
            foreach (var c in counts)
            {
                var sqrt = (int)Math.Ceiling(Math.Sqrt(c));
                totals += sqrt;
            }

            var remsqrts = 0;

            for (var i = 1; i <= n; i++ )
            {
                if (!alledges.Contains(i))
                    remsqrts++;
            }

            return totals + remsqrts;
            
        }










        private static readonly (int dx, int dy)[] directions = { (0, 1), (1, 0), (0, -1), (-1, 0) };
        internal List<string> doesCircleExist(List<string> commands)
        {
            var initiald = 0;
            var diridx = 0;

            var bwc = new List<string>();

           
            foreach (var command in commands)
            {

                (int x, int y) position = (0, 0);
                foreach (var c in command)
                {



                    switch (c)
                    {
                        case 'G':
                          
                            position.x += directions[diridx].dx;
                            position.y += directions[diridx].dy;
                            break;
                        case 'L':
                          
                            diridx = (diridx + directions.Length - 1) % directions.Length;
                            break;
                        case 'R':
                          
                            diridx = (diridx + 1) % directions.Length;
                            break;
                        default:
                            break;

                    }

                }
                if (position.x == 0 && position.y == 0)
                    bwc.Add("YES");
                else
                    bwc.Add("NO");

            }

          


            return bwc;

        }



        internal List<int> foo(int flightDuration, List<int> movieDuration)
        {
            var sortedlist = new List<int>();
            sortedlist.AddRange(movieDuration);
            sortedlist.Sort();

            var i = 0;
            var j = movieDuration.Count - 1;
            var max = -1;

            var movie1len = 0;
            var movie2len = 0;
            var maxlen = 0;

            while (i < j)
            {
                var sum = sortedlist[i] + sortedlist[j];
                if (sum == flightDuration - 30)
                {
                    if (sortedlist[i] > maxlen || sortedlist[j] > maxlen)
                    {
                        movie1len = sortedlist[i];
                        movie2len = sortedlist[j];
                        max = sum;
                        maxlen = Math.Max(movie1len, movie2len);
                    }
                    i++;
                    j--;
                }
                else if (sum < (flightDuration - 30))
                    i++;
                else
                    j--;


            }



            var mtw = new List<int>();
            if (max == -1)
            {
                mtw.AddRange(new int[] { -1, -1 });
            }
            else
                mtw.AddRange(new int[] { movieDuration.IndexOf(movie1len), movieDuration.IndexOf(movie2len) });
            mtw.Sort();
            return mtw;
        }



        internal void countSwaps(int[] a)
        {
            var swaps = 0;
            var n = a.Length;
            for (int i = 0; i < n; i++)
            {

                for (int j = 0; j < n - 1; j++)
                {
                    // Swap adjacent elements if they are in decreasing order
                    if (a[j] > a[j + 1])
                    {
                        var temp = a[j];
                        a[j] = a[j + 1];
                        a[j + 1] = temp;
                        swaps++;
                    }
                }

            }
            Console.WriteLine($"Array is sorted in {swaps} swaps.");
            Console.WriteLine($"First Element: {a[0]}");
            Console.WriteLine($"Last Element: {a[n - 1]}");

        }




        internal long repeatedString(string s, long n)
        {
            if (s == "a")
                return n;


            var numas = s.Where(st => st == 'a').Count();
            long count = (n / s.Length) * numas;
            long remainder = n % s.Length;


            for (var i = 0; i < remainder; i++)
            {
                if (s[i] == 'a')
                    count++;
            }
            return count;
        }




        internal long arrayManipulation(int n, int[][] queries)
        {
            var arr = new long[n + 1];

            for (var i = 0; i < queries.Length; i++)
            {
                arr[queries[i][0] - 1] += queries[i][2];
                arr[queries[i][1]] -= queries[i][2];
            }
            long max = long.MinValue;

            for (var k = 1; k < arr.Length; k++)
            {
                arr[k] += arr[k - 1];
                max = Math.Max(arr[k], max);
            }
            return max;

        }


        internal void minimumBribes(int[] q)
        {
            var count = 0;
            var vts = q.Length;

            while (vts > 1)
            {
                if (q[vts - 1] != vts)
                {
                    if (vts > 2 && q[vts - 3] == vts)
                    {
                        var index = vts - 3;
                        q[index] = q[index + 1];
                        q[index + 1] = q[index + 2];
                        q[index + 2] = vts;
                        count += 2;
                    }
                    else if (q[vts - 2] == vts)
                    {
                        var index = vts - 2;
                        var temp = q[index];
                        q[index] = q[index + 1];
                        q[index + 1] = temp;
                        count++;
                    }
                    else
                    {
                        Console.WriteLine("Too chaotic");
                        return;
                    }
                }
                vts--;
            }
            Console.WriteLine(count);

        }








        public int minimumSwaps(int[] arr)
        {
            var count = 0;
            for (var i = 0; i < arr.Length - 1; i++)
            {
                if (arr[i] != i + 1)
                {
                    var temp = arr[arr[i] - 1];
                    arr[arr[i] - 1] = arr[i];
                    arr[i] = temp;
                    i--;
                    count++;
                }
            }
            return count;


        }


        public int sockMerchant(int n, int[] ar)
        {
            var dict = new Dictionary<int, int>();
            for (var i = 0; i < n; i++)
            {
                if (!dict.ContainsKey(ar[i]))
                {
                    dict.Add(ar[i], 1);
                }
                else
                    dict[ar[i]]++;
            }
            var results = dict.Select(d => d.Value / 2).Sum();
            return results;

        }



        //figure this out

        public int MinReorder(int n, int[][] connections)
        {
            var graph = new Dictionary<int, HashSet<int>[]>();
            for (int i = 0; i < n; i++)
                graph[i] = new HashSet<int>[] { new HashSet<int>(), new HashSet<int>() };

            foreach (var edge in connections)
            {
                int u = edge[0], v = edge[1];
                graph[u][0].Add(v);
                graph[v][1].Add(u);
            }

            return DFS(graph, 0, new HashSet<int>());
        }

        private int DFS(Dictionary<int, HashSet<int>[]> graph, int curr, HashSet<int> visited)
        {
            int result = 0;
            if (visited.Count == graph.Count) return result;
            visited.Add(curr);
            foreach (var next in graph[curr][0])
                if (visited.Add(next))
                    result += 1 + DFS(graph, next, visited);

            foreach (var next in graph[curr][1])
                if (visited.Add(next))
                    result += DFS(graph, next, visited);

            return result;
        }



        /*
 * // This is the custom function interface.
 * // You should not implement it, or speculate about its implementation
 * public class CustomFunction {
 *     // Returns f(x, y) for any given positive integers x and y.
 *     // Note that f(x, y) is increasing with respect to both x and y.
 *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)
 *     public int f(int x, int y);
 * };
 */
        //public IList<IList<int>> FindSolution(CustomFunction customfunction, int z)
        //{
        //    var results = new List<IList<int>>();
        //    var maxj = 1000;

        //    for (var i = 1; i <= 1000; i++)
        //        for (var j = 1; j <= maxj; j++)
        //        {
        //            if (customfunction.f(i, j) == z)
        //            {
        //                results.Add(new List<int>() { i, j });
        //                maxj = j;
        //            }
        //        }

        //    return results;

        //}









        public int NumRollsToTarget(int d, int f, int target)
        {
            var dp = new int[target + 1];
            dp[0] = 1;
            for (int i = 1; i <= d; i++)
            {
                var tempdp = new int[target + 1];
                for (var j = 1; j <= f; j++)
                    for (var k = j; k <= target; k++)
                        tempdp[k] = (tempdp[k] + dp[k - j]) % 1_000_000_007;
                dp = tempdp;
            }

            return dp[target];
        }



        public IList<IList<int>> CombinationSum(int[] candidates, int target)
        {
            var result = new List<IList<int>>();
            if (candidates.Length == 0)
                return result;
            Array.Sort(candidates);
            Traverse(result, candidates, target, 0, new List<int>());
            return result;

        }

        private void Traverse(IList<IList<int>> result, int[] candidates, int target, int start, IList<int> oneresult)
        {
            if (target == 0)
                result.Add(new List<int>(oneresult));
            else if (target > 0)
            {
                for (var i = start; i < candidates.Length; i++)
                {
                    oneresult.Add(candidates[i]);
                    Traverse(result, candidates, target - candidates[i], i, oneresult);
                    oneresult.RemoveAt(oneresult.Count - 1);

                }
            }

        }



        public int[] SortKMessedArray(int[] arr, int k)
        {
            List<int> priorityQueue = new List<int>();

            // add first k + 1 items to the min heap
            for (int i = 0; i < k + 1; i++)
            {
                priorityQueue.Add(arr[i]);
            }

            priorityQueue.Sort();

            int index = 0;
            for (int i = k + 1; i < arr.Length; i++)
            {
                arr[index++] = priorityQueue[0];
                priorityQueue.RemoveAt(0);
                priorityQueue.Add(arr[i]);
                priorityQueue.Sort();
            }

            int queue_size = priorityQueue.Count;

            for (int i = 0; i < queue_size; i++)
            {
                arr[index++] = priorityQueue[0];
                priorityQueue.RemoveAt(0);
            }

            return arr;

        }



public string CustomSortString2(string S, string T)
        {
            
            var result = new StringBuilder();
            for (var i = 0; i < S.Length; i++)
            {
                var search = S[i];
                var count = T.Count(t => t == search);

                if (count > 0)
                {
                    result.Append(new String(search, count));

                    
                    T = T.Replace(search, ' ');
                }

            }
            T = T.Trim().Replace(" ", String.Empty);
            return result.ToString() + T;
        }


        public IList<int> FindDisappearedNumbers(int[] nums)
        {




            return Enumerable.Range(1, nums.Length).Except(nums).ToList();


            //This takes too long:
            //Array.Sort(nums);
            //var result = new List<int>();
            //nums = nums.Distinct().ToArray();
            //for (var i = 0; i < nums.Length - 1; i++)
            //{
            //    if (nums[i + 1] - nums[i] > 1)
            //    {
            //        result.AddRange(Enumerable.Range(nums[i] + 1, nums[i + 1] - 1).ToList());
            //    }
            //}
            //return result;
        }


        public string MostCommonWord(string paragraph, string[] banned)
            {
               
                var clean = paragraph.Replace("!", " ")
                                                 .Replace("?", " ")
                                                 .Replace("'", " ")
                                                 .Replace(",", " ")
                                                 .Replace(";", " ")
                                                 .Replace(".", " ");

                var words = clean.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                var dict = new Dictionary<string, int>();
                for (var i = 0; i < words.Length; i++)
                {
                    var word = words[i].Where(l => char.IsLetterOrDigit(l));
                    var arr = new string(word.ToArray()).ToLower();
                    if (!banned.Contains(arr))
                    {
                        if (!dict.ContainsKey(arr))
                            dict.Add(arr, 1);
                        else
                            dict[arr]++;
                    }
                }
                var c = dict.OrderByDescending(d => d.Value).Select(d => d.Key).FirstOrDefault();
                return c;
            }


            public int SwimInWater(int[][] grid)
            {
                var low = grid[0][0];
                var high = low;
                for (var r = 0; r < grid.Length; r++)
                {
                    var row = grid[r];
                    for (var c = 0; c < row.Length; c++)
                    {
                        high = Math.Max(row[c], high);
                    }
                }

                while (low < high)
                {
                    var mid = low + (high - low) / 2;

                    if (PathExists(grid, mid, 0, 0, new bool[grid.Length, grid[0].Length]))
                        high = mid;
                    else
                        low = mid + 1;
                }

                return low;
            }

            private bool PathExists(int[][] grid, int waterLevel, int r, int c, bool[,] visited)
            {
                if (r > grid.Length - 1 || r < 0 || c > grid[0].Length - 1 || c < 0)
                    return false;

                if (grid[r][c] > waterLevel || visited[r, c] == true)
                    return false;

                if (r == grid.Length - 1 && c == grid[0].Length - 1)
                    return true;

                visited[r, c] = true;

                var directions = new (int x, int y)[] { (1, 0), (0, 1), (-1, 0), (0, -1) };

                foreach (var dir in directions)
                {
                    if (PathExists(grid, waterLevel, r + dir.x, c + dir.y, visited))
                        return true;
                }

                return false;
            }


            public int SumOfUnique(int[] nums)
            {
                var uniques = nums.GroupBy(n => n).Where(n => n.Count() == 1).Select(n => n.Key).ToArray();
                var sum = uniques.Sum();
                return sum;
            }
        


        public int NumSubmat(int[][] mat)
            {
                int[,] grid = new int[mat.Length + 1, mat[0].Length + 1];

                int count = 0;
                int min;

                for (int i = mat.Length - 1; i >= 0; i--)
                {
                    for (int j = mat[0].Length - 1; j >= 0; j--)
                    {
                        if (mat[i][j] == 1)
                        {
                            grid[i, j] = 1 + grid[i, j + 1];

                            count += grid[i, j];

                            min = grid[i, j];

                            for (int h = i + 1; h < mat.Length; h++)
                            {
                                min = Math.Min(min, grid[h, j]);
                                if (min > 0) { count += min; } else { break; }
                            }
                        }
                    }
                }

                return count;
            }


            internal bool HasDupes(int[] arr)
            {
                if (arr == null)
                    return false;
                if (arr.Length <= 1)
                    return false;
                Array.Sort(arr);

                for (var i = 0; i < arr.Length - 1; i++)
                {
                    if (arr[i] == arr[i + 1])
                        return true;
                }
                return false;

            }




            public int FindSpecialInteger(int[] arr)
            {
                if (arr.Length == 1)
                    return arr[0];
                var percentage = arr.Length / 4;
                if (arr.Length % 4 > 0)
                    percentage++;
                var dict = new Dictionary<int, int>();
                for (var i = 0; i < arr.Length; i++)
                {
                    if (!dict.ContainsKey(arr[i]))
                    {
                        dict.Add(arr[i], 1);
                    }
                    else
                    {
                        dict[arr[i]]++;
                    }
                }

                var key = dict.Where(d => d.Value == dict.Values.Max()).Select(d => d.Key).FirstOrDefault();
                var order = dict.GroupBy(d => d.Value).OrderByDescending(d => d.Key).Select(d => d.Key).FirstOrDefault(); // Values.OrderBy(d => d .OrderBy(d => d.Count).FirstOrDefault();
                return key;
            }



            public int UniquePathsIII(int[][] grid)
            {
                var start = new int[2];
                var emptycells = 0;
                var paths = 0;
                for (var i = 0; i < grid.Length; i++)
                    for (var j = 0; j < grid[i].Length; j++)
                    {
                        if (grid[i][j] == 1)
                        {
                            start[0] = i;
                            start[1] = j;
                        }
                        else
                            if (grid[i][j] == 0)
                        {
                            emptycells++;
                        }

                    }


                Traverse(grid, start[0], start[1], emptycells, 0, new int[grid.Length, grid[0].Length], ref paths);
                return paths;


            }


            void Traverse(int[][] grid, int i, int j, int emptycells, int emptyfound, int[,] visited, ref int paths)
            {

                if (i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || visited[i, j] == 1 || grid[i][j] == -1)
                    return;

                else if (grid[i][j] == 2)
                {
                    if (emptyfound == emptycells)
                        paths++;
                }
                else if (grid[i][j] == 0)
                    emptyfound++;



                visited[i, j] = 1;

                Traverse(grid, i - 1, j, emptycells, emptyfound, visited, ref paths);
                Traverse(grid, i + 1, j, emptycells, emptyfound, visited, ref paths);
                Traverse(grid, i, j - 1, emptycells, emptyfound, visited, ref paths);
                Traverse(grid, i, j + 1, emptycells, emptyfound, visited, ref paths);

                visited[i, j] = 0;



            }










            public int CountBattleships(char[][] board)
            {
                var count = 0;

                for (var i = 0; i < board.Length; i++)
                {
                    for (var j = 0; j < board[i].Length; j++)
                    {
                        if (board[i][j] == 'X')
                        {
                            if (i < (board.Length - 1) && board[i + 1][j] == 'X')
                                continue;
                            if (j < (board[i].Length - 1) && board[i][j + 1] == 'X')
                                continue;
                            count++;

                        }
                    }

                }
                return count;
            }

            public int MyAtoi3(string s)
            {
                if (string.IsNullOrEmpty(s))
                    return 0;
                var negative = 1;
                var sbnumber = new StringBuilder();

                var i = 0;
                while (i < s.Length && s[i] == ' ')
                    i++;
                if (i < s.Length && s[i] == '-')
                {
                    negative = -1;
                    i++;
                }
                else if (i < s.Length && s[i] == '+')
                    i++;
                if (i < s.Length && !Char.IsNumber(s[i]))
                    return 0;
                while (i < s.Length && Char.IsNumber(s[i]))
                {
                    sbnumber.Append(s[i]);
                    i++;
                }

                if (sbnumber.Length == 0)
                    return 0;
                long num = 0;
                
                var success = Int64.TryParse(sbnumber.ToString(), out num);

                if (!success)
                {
                    if (negative == 1)
                        return Int32.MaxValue;
                    else
                        return Int32.MinValue;
                }


                num *= negative;
                if (num > Int32.MaxValue)
                    return Int32.MaxValue;


                if (num < Int32.MinValue)
                    return Int32.MinValue;

                return Convert.ToInt32(num);
            }









            public void SetZeroes(int[][] matrix)
            { 
                
                var rows = new List<int>();
                var columns = new List<int>();
                for (var i = 0; i < matrix.Length; i++)
                    for (var j = 0; j < matrix[i].Length; j++)
                    {
                        if (matrix[i][j] == 0)
                        {
                            rows.Add(i);
                            columns.Add(j);

                          //  matrix[0][j] = 0;
                          //  matrix[i][0] = 0;
                           // break;
                        }
                    }


                for (var i = 0; i < matrix.Length; i++)
                    for (var j = 0; j < matrix[i].Length; j++)
                    {
                        if (rows.Contains(i) || columns.Contains(j))
                        {
                            matrix[i][j] = 0;
                        }
                    }
              


            }



            public IList<int> LuckyNumbers(int[][] matrix)
            {
                var mineachrow = new List<int>();
                var maxeachcol = new List<int>();

                for (var i = 0; i < matrix.Length; i++)
                {
                    var minrow = Int32.MaxValue;

                    for (var j = 0; j < matrix[i].Length; j++)
                    {
                        if (matrix[i][j] < minrow)
                            minrow = matrix[i][j];
                    }
                    mineachrow.Add(minrow);
                }


                for (var j = 0; j < matrix[0].Length; j++)
                {
                    var maxcol = 0;
                    for (var i = 0; i < matrix.Length; i++)

                   
                    {
                        if (matrix[i][j] > maxcol)
                            maxcol = matrix[i][j];
                    }
                    maxeachcol.Add(maxcol);
                }


                return maxeachcol.Intersect(mineachrow).ToList();
            }



            public bool Check(int[] nums)
            {
                var numlist = nums.ToList();
                int[] sorted = new int[nums.Length];
                nums.CopyTo(sorted, 0);
                Array.Sort(sorted);
               
                if (nums.SequenceEqual(sorted))
                    return true;
                for (var i = 0; i < nums.Length; i++)
                {
                    var numtoremove = numlist[0];
                    numlist.RemoveAt(0);
                    numlist.Add(numtoremove);
                    if (numlist.SequenceEqual(sorted))
                        return true;
                }
                return false;

            }


            int total = 0;

            public int DistributeCoins(TreeNode root)
            {
                GetTotal(root);
                return total;
            }
            internal int GetTotal(TreeNode node)
            {
                if (node == null)
                    return 0;
                var l = GetTotal(node.left);
                var r = GetTotal(node.right);
                total += Math.Abs(l) + Math.Abs(r);
                return node.val + l + r - 1;


            }



            public bool Exist(char[][] board, string word)
            {
                int m = board.Length, n = board[0].Length;
                for (int i = 0; i < m; i++)
                    for (int j = 0; j < n; j++)
                        if (ExistsWord(i, j, 0, new HashSet<(int, int)>()))
                            return true;

                return false;

                bool ExistsWord(int i, int j, int wordIndex, HashSet<(int, int)> visited)
                {
                    if (i >= m || j >= n || i < 0 || j < 0 || visited.Contains((i, j)) || board[i][j] != word[wordIndex])
                        return false;
                    if (wordIndex == word.Length - 1)
                        return true;
                    visited.Add((i, j));

                    bool res = ExistsWord(i + 1, j, wordIndex + 1, visited) ||
                               ExistsWord(i - 1, j, wordIndex + 1, visited) ||
                               ExistsWord(i, j + 1, wordIndex + 1, visited) ||
                               ExistsWord(i, j - 1, wordIndex + 1, visited);

                    visited.Remove((i, j));

                    return res;
                }
            }







            public int MaxRepOpt2(string text)
            {
                var list = new List<int>[26];


                //list[0] = new List<int>();
                //list[0].Add(2);
                //list[0].Add(3);
                //list[0].Add(4);
                //list[0].Add(5);
                //list[0].Add(6);
                //list[0].Add(7);
                //list[0].Add(8);


                for (var i = 0; i < text.Length; i++)
                {
                    if (list[text[i] - 'a'] == null)
                        list[text[i] - 'a'] = new List<int>();
                    list[text[i] - 'a'].Add(i);
                }

                var max = 1;

                for (var i = 0; i <= 25; i++)
                {
                    var cons = 1;
                    var cons1 = 0;
                    var res = 0;
                    if (list[i] != null)
                    {
                        for (var j = 1; j < list[i].Count; j++)
                        {
                            if (list[i][j] == list[i][j - 1] + 1)
                                cons++;
                            else
                            {
                                cons1 = list[i][j] == list[i][j - 1] + 2 ? cons : 0;
                                cons = 1;
                            }

                            res = Math.Max(res, cons + cons1);
                        }
                    }

                    max = Math.Max(max, (list[i]?.Count ?? 0) > res ? res + 1 : res);
                }

                return max;
            }




            public int MaxRepOpt1(string text)
            {
                //char, index, count;
                var occur = new List<KeyValuePair<char, KeyValuePair<int, int>>>();

                if (text.Length == 1)
                    return 1;
                var length = 1;
                var startindex = 0;
                for (var i = 1; i < text.Length; i++)
                {
                    if (text[i] != text[i - 1])
                    {
                        occur.Add(new KeyValuePair<char, KeyValuePair<int, int>>( text[i - 1], new KeyValuePair<int, int>(startindex, length)));
                        length = 1;
                        startindex = i;
                    }
                    else
                    {
                        length++;
                    }
                }

                occur.Add(new KeyValuePair<char, KeyValuePair<int, int>>(text[text.Length-1], new KeyValuePair<int, int>(startindex, length)));

                var maxrep = occur.GroupBy(g => g.Key).Select(group => new
                {
                    letter = group.Key,
                    count = group.Count()
                }).OrderBy(o => o.letter);



                //var maxrep = occur.GroupBy(o => o.Key).Select(o => new { a = o.Key, b = o.Select(x => new { name = x.Value.Value})}
              
                //var max = maxrep.Where(m => m.Key.)

                return 1;


            }



            /*
Function exact_match(text, pattern) returns true if pattern is an exact substring of text.
"hello world", "hello" => true
"hello world", "llo wor" => true
"hello world", "hello world hello" => false


Function wildcard_match(text, pattern) adds the wildcard metacharacter . (period) to the pattern character set. This metacharacter matches any character in text.
"hello world", ".ello"  => true
"hello world", "..llo.wor" => true
"hello world", "..l.o" => true
"hello world", "...llo" => false
"hello world", "or.." => true
"hello world", "or..." => false

1. iterate through text
2. iterate from current position in text through pattern
3. if reached end of pattern return true


Function question_wildcard_match(text, pattern) adds the metacharacter ? to the pattern character set. x? in pattern matches either zero occurrences or one occurrence of x in text, where x is not ? . Assume valid input.\
"hello world", "hell?o" => True
"hello world", "helll?o" => True
"hello world", "hell?lo" => True
"hello world", ".?ell?l?l?o?o?" => True
"hello world", "llog?z? k" => False

"aaab", "a?a?aab"

Dynamic Programming - 
*/





    //fix this one:

    internal bool wildcard_match(string text, string pattern) // O(n*m)
        { // O(1) SC
            var count = 0;
            //if pattern.Length > text.Length?
            //if pattern == ""?
            var plen = pattern.Length;

            for (var i = 0; i < text.Length; i++) // O(n-m)
            {
                count = 0;
                while (count < plen &&  // O(m)
                      (text[i + count] == pattern[count] || pattern[count] == '.'))
                {
                    count++;
                }
                if (count == plen)
                    return true;

            }
            return false;

        }


        //public static bool question_wildcard_match(string text, string pattern)
        //{

        //    var count = 0;
        //    var plen = pattern.Length;

        //    for (var i = 0; i < text.Length - plen; i++)
        //    {


        //        while (text[i] == pattern[count] || pattern[count] == '?')
        //        {
        //            if (pattern[count] == '?')
        //            {

        //            }
        //        }


        //    }



        //}





        int maxlevel = 1;
        int sum = 0;
        public int DeepestLeavesSum(TreeNode root)
        {
            Traverse(root, maxlevel);
            Traverse(root.left, maxlevel + 1);
            Traverse(root.left, maxlevel + 1);
            return sum;
        }

        private void Traverse(TreeNode node, int level)
        {
            if (node == null)
                return;
            if (level > maxlevel)
            {
                maxlevel = level;
                sum = node.val;
            }
            else
            {
                sum += node.val;
            }
            Traverse(node.left, level + 1);
            Traverse(node.right, level + 1);
        }









        public string ReverseOnlyLetters(string S)
        {
            var nonletters = new List<KeyValuePair<int, char>>();
            var nonindex = 0;
            for (var i = 0; i < S.Length; i++)
            {
                if (!Char.IsLetter(S[i]))
                {
                    nonletters.Add(new KeyValuePair<int, char>(nonindex, S[i]));
                    S = S.Remove(i, 1);
                    i--;
                    
                }
                nonindex++;
            }
            var revca = S.Reverse();
            var reversed = new string(revca.ToArray());
            var sb = new StringBuilder(reversed);
            for (var i = 0; i < nonletters.Count; i++)
            {
                sb.Insert(nonletters.ElementAt(i).Key, nonletters.ElementAt(i).Value);
            }
            return sb.ToString();
        }


        public bool IsOneEditDistance2(string s, string t)
        {
            var edits = 1;
            int abs = Math.Abs(s.Length - t.Length);
            if (abs > edits)
                return false;

            int edit = 0;
            for (int i = 0; i < s.Length && i < t.Length; i++)
            {
                if (s[i] != t[i])
                    edit++;
                if (edit == edits + 1)
                    return false;
            }

            return abs + edit <= edits;
        }


public bool IsOneEditDistance(string s, string t)
        {
            if (String.IsNullOrEmpty(s) && String.IsNullOrEmpty(t))
                return false;
            if (s == t)
                return false;

            var len = s.Length;
            for (var i = 0; i < s.Length && s.Length > 0 && t.Length > 0; i++)
            {
                var c = s[i].ToString();
                if (s.Contains(c) && t.Contains(c))
                { 
                    s = s.Replace( c, "");
                    t = t.Replace(c, "");
                    i--;
                }
            }
            if (s.Length == 1 && t.Length == 1)
                return true;
            if (s.Length == 0 && t.Length == 1)
                return true;
            if (s.Length == 1 && t.Length == 0)
                return true;
            return false;
        }





        public ListNode AddTwoNumbers8(ListNode l1, ListNode l2)
        {
            var s1 = new Stack<int>();
            var s2 = new Stack<int>();

            while (l1 != null)
            {
                s1.Push(l1.val);
                l1 = l1.next;
            }

            while (l2 != null)
            {
                s2.Push(l2.val);
                l2 = l2.next;
            }

            var carry = 0;
            var l3 = new ListNode(-1);
            ListNode head = null;
            while (s1.Count > 0 || s2.Count > 0 || carry > 0)
            {
                var sum = (s1.Count > 0 ? s1.Pop() : 0) + (s2.Count > 0 ? s2.Pop() : 0) + carry;
                carry = sum / 10;
                sum %= 10;

                if (l3.val == -1)
                    l3.val = sum;
                else
                {
                    head = new ListNode(sum);
                    head.next = l3;
                    l3 = head;
                }

            }
            return l3;

        }






        char[][] _board = null;
        List<string> _result = new List<string>();

        public List<string> findWords(char[][] board, string[] words)
        {

            // Step 1). Construct the Trie
            TrieNode root = new TrieNode();
            foreach (var word in words)
            {
                TrieNode node = root;

                foreach (var letter in word)
                {
                    if (node.children.ContainsKey(letter))
                    {
                        node = node.children[letter];
                    }
                    else
                    {
                        TrieNode newNode = new TrieNode();
                        node.children.Add(letter, newNode);
                        node = newNode;
                    }
                }
                node.word = word;  // store words in Trie
            }

            this._board = board;
            // Step 2). Backtracking starting for each cell in the board
            for (int row = 0; row < board.Length; ++row)
            {
                for (int col = 0; col < board[row].Length; ++col)
                {
                    if (root.children.ContainsKey(board[row][col]))
                    {
                        backtracking(row, col, root);
                    }
                }
            }

            return this._result;
        }

        private void backtracking(int row, int col, TrieNode parent)
        {
            var letter = this._board[row][col];
            TrieNode currNode = parent.children[letter];

            // check if there is any match
            if (currNode.word != null)
            {
                this._result.Add(currNode.word);
                currNode.word = null;
            }

            // mark the current letter before the EXPLORATION
            this._board[row][col] = '#';

            // explore neighbor cells in around-clock directions: up, right, down, left
            int[] rowOffset = { -1, 0, 1, 0 };
            int[] colOffset = { 0, 1, 0, -1 };
            for (int i = 0; i < 4; ++i)
            {
                int newRow = row + rowOffset[i];
                int newCol = col + colOffset[i];
                if (newRow < 0 || newRow >= this._board.Length || newCol < 0
                    || newCol >= this._board[0].Length)
                {
                    continue;
                }
                if (currNode.children.ContainsKey(this._board[newRow][newCol]))
                {
                    backtracking(newRow, newCol, currNode);
                }
            }

            // End of EXPLORATION, restore the original letter in the board.
            this._board[row][col] = letter;

            // Optimization: incrementally remove the leaf nodes
            if (currNode.children.Count == 0)
            {
                parent.children.Remove(letter);
            }
        }
        //  }




      //  2 5 3 4 6 2 2
        public ListNode SwapPairs2(ListNode head)
        {
            if (head == null || head.next == null)
                return head;
            ListNode newhead = null;
            var tail = head.next;
            ListNode prev = null;
            while (head != null && head.next != null)
            {
                head.next = tail.next;
                tail.next = head;
                if (newhead == null)
                {
                    newhead = tail;
                    prev = head;
                }
                else
                {
                    prev.next = tail;
                    prev = prev.next.next;
                }
                head = tail.next.next;
                tail = head?.next;

            }
            return newhead;
        }







        //class Solution
        // {


        public ListNode SwapPairs(ListNode head)
        {

            if (head == null || head.next == null)
                return head;
            
            var node = head.next;
            var returnhead = head.next;
            head.next = node.next;
            node.next = head;
            var tail = head;
            head = head.next;

            while (head?.next != null)
            {
                node = head.next;
                head.next = node.next;
                node.next = head;
                tail.next = node;
                tail = head;
                head = head.next;
            }
            return returnhead;
        }


        public string ReverseWords(string s)
        {
            var words = s.Split(' ');
            var sb = new StringBuilder();
            for (var i = 0; i < words.Length; i++)
            {
                var ary = words[i].ToArray();
                Array.Reverse(ary);
                sb.Append(new string(ary));
                if (i < words.Length - 1)
                    sb.Append(" ");

            }
            return sb.ToString();
        }



        public void dfs(int[][] M, int[] visited, int i)
        {
            for (int j = 0; j < M.Length; j++)
            {
                if (M[i][j] == 1 && visited[j] == 0)
                {
                    visited[j] = 1;
                    dfs(M, visited, j);
                }
            }
        }
        public int FindCircleNum(int[][] M)
        {
            int[] visited = new int[M.Length];
            int count = 0;
            for (int i = 0; i < M.Length; i++)
            {
                if (visited[i] == 0)
                {
                    dfs(M, visited, i);
                    count++;
                }
            }
            return count;
        }

        //public int FindCircleNum(int[][] isConnected)
        //{
        //    var members = new List<int>();
        //    for (var i = 0; i < isConnected.Length; i++)
        //    {
        //        for (var j = 0; j < isConnected[i].Length; j++)
        //        {
        //            if (i != j && isConnected[i][j] == 1)
        //            {
        //                members.Add(i);
        //                members.Add(j);
        //            }
        //        }
        //    }
        //    members = members.Distinct().ToList();
        //    var solemembers = isConnected.Length - members.Count;
        //    return solemembers == isConnected.Length ? solemembers : solemembers + 1;

        //}

        //public int knightDialer(int N)
        //{
        //    int MOD = 1_000_000_007;


        //    int[][] moves = new int[][]() {{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};

        //    int[][] dp = new int[2][10];
        //    Array.Fill(dp[0], 1);
        //    for (int hops = 0; hops < N - 1; ++hops)
        //    {
        //        Array.Fill(dp[~hops & 1], 0);
        //        for (int node = 0; node < 10; ++node)
        //            for (int nei: moves[node])
        //            {
        //                dp[~hops & 1][nei] += dp[hops & 1][node];
        //                dp[~hops & 1][nei] %= MOD;
        //            }
        //    }

        //    long ans = 0;
        //    for (int x: dp[~N & 1])
        //        ans += x;
        //    return (int)(ans % MOD);
        //}












        public ListNode DetectCycle(ListNode head)
        {
            var nodes = new List<ListNode>();
            var pos = 0;
            while (head != null)
            {
                if (!nodes.Contains(head))
                {
                    nodes.Add(head);
                    pos++;
                    head = head.next;
                }
                else
                {
                    return head;
                }

            }
            return null;
        }



        public ListNode OddEvenList(ListNode head)
        {
            if (head == null)
                return null;

            var odd = head;
            var headodd = head;
            var even = head.next;
            var headeven = head.next;
            head = head?.next?.next;
            while (head != null)
            {
                odd.next = head;
                even.next = head.next;
                head = head?.next?.next;
                if (head != null)
                {

                    even = even.next;
                }
                odd = odd.next;

            }

            odd.next = headeven;
            return headodd;


        }


        public int FindCelebrity(int n)
        {
            for (var i = 0; i < n; i++)
            {
                var celeb = true;
                for (var j = 0; j < n; j++)
                {
                    if (i != j)  // && Knows(i, j) || !Knows(j, i))
                    {
                        celeb = false;
                        // Console.WriteLine($"{i} DOES know {j}");
                        break;
                    }
                    //  Console.WriteLine($"{i} doesnt know {j}");

                }
                if (celeb)
                    return i;
            }

            return -1;
        }

        protected internal int MaxSubArray2(int[] nums)
        {
            var maxval = nums[0];
            for (var i = 1; i < nums.Length; i ++)
            {
                if (nums[i-1] > 0)
                    nums[i] = nums[i - 1] + nums[i];
                maxval = Math.Max(maxval, nums[i]);
            }
            return maxval;
        }


        List<int> sequence = new List<int>();
        public bool LeafSimilar3(TreeNode root1, TreeNode root2)
        {

            Traverse(root1);
            var s1 = new List<int>();
            s1.AddRange(sequence);

            sequence.Clear();
            Traverse(root2);
            var s2 = new List<int>();
            s2.AddRange(sequence);

            return (s1.SequenceEqual(s2));

        }

        private void Traverse(TreeNode node)
        {
            if (node == null)
                return;
            if (node.left == null && node.right == null)
            {
                sequence.Add(node.val);
            }
            if (node.left != null)
                Traverse(node.left);
            if (node.right != null)
                Traverse(node.right);

        }


        public string Multiply(string num1, string num2)
        {
            int n1 = num1.Length;
            int n2 = num2.Length;
            int[] products = new int[n1 + n2];

            for (int i = n1 - 1; i >= 0; i--)
            {
                for (int j = n2 - 1; j >= 0; j--)
                {
                    int p1 = i + j;
                    int p2 = p1 + 1;
                    int sum = (num1[i] - '0') * (num2[j] - '0') + products[p2];

                    products[p1] += sum / 10;
                    products[p2] = sum % 10;
                }
            }

            StringBuilder sb = new StringBuilder();
            foreach (int num in products)
            {
                if (!(sb.Length == 0 && num == 0))
                {
                    sb.Append(num);
                }
            }

            return sb.Length == 0 ? "0" : sb.ToString();
        }

        public int CompareVersion(string version1, string version2)
        {
            var v1 = version1.Split('.').ToList();
            var v2 = version2.Split('.').ToList();
            var diff = v1.Count - v2.Count;
            if (diff > 0)
            {
                for (var i = 0; i < diff; i++)
                {
                    v2.Add("0");
                }
            }
            else if (diff < 0)
            {
                for (var i = 0; i < Math.Abs(diff); i++)
                {
                    v1.Add("0");
                }
            }

          
            for (var i = 0; i < v1.Count; i++)
            {
                if (Convert.ToInt32(v1[i]) > Convert.ToInt32(v2[i]))
                {
                    return 1;

                }
                else if (Convert.ToInt32(v1[i]) < Convert.ToInt32(v2[i]))
                {
                    return -1;

                }
                

            }


            return 0;
        }


        /// <summary>
        /// works great, and has tricky step of adding new list, and attaching head to itself, etc.
        /// </summary>
        /// <param name="l1"></param>
        /// <param name="l2"></param>
        /// <returns></returns>
        public ListNode AddTwoNumbers7(ListNode l1, ListNode l2)
        {
            var s1 = new Stack<int>();
            var s2 = new Stack<int>();

            while (l1 != null)
            {
                s1.Push(l1.val);
                l1 = l1.next;
            }

            while (l2 != null)
            {
                s2.Push(l2.val);
                l2 = l2.next;
            }

            var carry = 0;
            ListNode head = null;
            while (s1.Count > 0 || s2.Count > 0 || carry > 0)
            {
                var sum = (s1.Count > 0 ? s1.Pop() : 0) + (s2.Count > 0 ? s2.Pop() : 0) + carry;
                carry = sum / 10;
                sum %= 10;

                var l3 = new ListNode(sum);
                l3.next = head;
                head = l3;
            }

            return head;
        }







        List<int> l = new List<int>();

        public bool LeafSimilar2(TreeNode root1, TreeNode root2)
        {
            var l1 = new List<int>();
            var l2 = new List<int>();
            Traverse(root1, l1);
          
            Traverse(root2, l2);
          

            return (l1.SequenceEqual(l2));

        }

        private void Traverse(TreeNode node, List<int> l)
        {
            if (node.left == null && node.right == null)
            {
                l.Add(node.val);
            }
            else
            {
                Traverse(node.left, l);
                Traverse(node.right, l);

            }
        }

    






    public IList<int> MajorityElement2(int[] nums)
        {
            var count = nums.Length / 3;
            var dict = new Dictionary<int, int>();
            for (var i = 0; i < nums.Length; i++)
            {
                if (!dict.ContainsKey(nums[i]))
                {
                    dict.Add(nums[i], 1);

                }
                else
                    dict[nums[i]]++;
            }
            var occured = dict.Where(d => d.Value > count).Select(d => d.Key).ToList();
            return occured;
        }


        public void NumArray(int[] nums)
        {
            var a = new List<int>();
            a.AddRange(nums);

        }




        public string LargestTimeFromDigits(int[] A)
        {
            int maxTime = -1;
            for (int i0 = 0; i0 < 4; i0++)
            {
                for (int i1 = 0; i1 < 4; i1++)
                {
                    if (i1 == i0)
                    {
                        continue;
                    }
                    for (int i2 = 0; i2 < 4; i2++)
                    {
                        if (i2 == i0 || i2 == i1)
                        {
                            continue;
                        }
                        int i3 = 6 - i0 - i1 - i2;
                        int hours = A[i0] * 10 + A[i1];
                        int mins = A[i2] * 10 + A[i3];
                        if (hours < 24 && mins < 60)
                        {
                            maxTime = Math.Max(maxTime, hours * 60 + mins);
                        }
                    }
                }
            }
            return maxTime >= 0 ? string.Format($"{maxTime / 60:00}:{maxTime % 60:00}") : string.Empty;
        }










        //works!!

        public int MaxDistToClosest(int[] seats)
        {
            var maxdistance = 0;
            var count = 0;
            var full = false;
            for (var i = 0; i < seats.Length; i++)
            {
                if (seats[i] == 1)
                {
                    if (full)
                    {
                        count++;
                        if (count / 2 > maxdistance)
                            maxdistance = count / 2;

                    }
                    else
                    {
                        if (count > maxdistance)
                            maxdistance = count;
                        full = true;
                    }

                    if (i < seats.Length - 1)
                        count = 0;

                }

                else if (seats[i] == 0)
                {
                    count++;
                    if (i == seats.Length - 1)
                    {
                        if (count > maxdistance)
                            maxdistance = count;
                    }
                }



            }
            return maxdistance;
        }









        ////copied solution
        //public ListNode ReverseList(ListNode head)
        //{

        //    ListNode prevNode = null;

        //    while (head != null) {
        //        var nextNode = head.next;
        //        head.next = prevNode;
        //        prevNode = head;
        //        head = nextNode;
        //    }

        //    return prevNode;


        //}


        public void InsertNode(ListNode node, int number)
        {
            var curr = node.val;
            node.val = number;
            while (node.next != null)
            {
                (node.next.val, curr) = (curr, node.next.val);
                node = node.next;
            }
            node.next = new ListNode(curr);
        }


        //public int Read(char[] buf, int n)
        //{

        //    var i = 0;

        //    while (i < n)
        //    {
        //        if (buf4index != -1 && numread > 0)
        //        {
        //            buf[i] = buf4[buf4index];
        //            buf4index++;
        //            i++;
        //            if (buf4index == numread)
        //                buf4index = -1;
        //        }
        //        else
        //        {
        //            buf4index = 0;
        //            numread = Read4(buf4);
        //            if (numread == 0)
        //                return i;
        //        }
        //    }
        //    return i;

        //}







        //int buf4index = -1;
        //char[] buf4 = new char[4];
        //int numread;
        //public int Readnotworking(char[] buf, int n)
        //{

        //    var count = 0;

        //    if (buf4index < 4 && buf4index > -1)
        //    {
        //        while (n > 0 && buf4index < numread)
        //        {
        //            Console.WriteLine("from past read: " + buf4[buf4index] + " count= " + count);
        //            buf[count] = buf4[buf4index];
        //            buf4index++;
        //            count++;
        //            n--;
        //        }
        //    }
        //    Console.WriteLine("buf4index TOP: " + buf4index);
        //    if (n == 0)
        //        return count;
        //    Console.WriteLine("after first if");

        //    numread = Read4(buf4);
        //    if (numread == 0)
        //    {
        //        if (count > 0)
        //            return count;
        //        else
        //            return 0;
        //    }


        //    buf4index = 0;
        //    while (n > 0 && count < numread)
        //    {
        //        Console.WriteLine("buf4[count]: " + buf4[buf4index]);
        //        buf[count] = buf4[buf4index];
        //        buf4index++;
        //        //i++;
        //        count++;
        //        n--;
        //    }

        //    Console.WriteLine("buf4index (bottom): " + buf4index);
        //    return count;

        //    //var o = new string(buf4);
        //    //Console.WriteLine("buf: " + o);
        //    //return a;
        //}


        public int LengthLongestPath(string input)
        {
            var lines = input.Split('\n');
            var max = 0;
            var pathLengthMap = new Dictionary<int, int>();
            pathLengthMap.Add(0, 0);
            for (int i = 0; i < lines.Length; i++)
            {
                var line = lines[i];
                var name = line.TrimStart('\t');
                var depth = line.Length - name.Length + 1;
                var length = pathLengthMap[depth - 1];
                length += name.Length;
                // if is file
                if (name.Contains('.'))
                {
                    max = Math.Max(max, length);
                }
                else // if is not file
                {
                    length++;
                    if (pathLengthMap.ContainsKey(depth)) pathLengthMap[depth] = length;
                    else pathLengthMap.Add(depth, length);
                }

            }
            return max;
        }






        public int MinSteps(string s, string t)
        {
            var dict = s.GroupBy(s => s).ToDictionary(s => s.Key, s => s.Count());
            var count = t.Length;
            for (var i = 0; i < t.Length; i++)
            {
                if (dict.ContainsKey(t[i]) && dict[t[i]] > 0)
                    {
                        dict[t[i]]--;
                    count--;
                    }
            }


            return count;
        }




                public int MinSteps2slow(string s, string t)
        {
           
            for (var i = 0; i < s.Length; i++)
            {
                var ti = t.IndexOf(s[i]);
                if (ti >= 0)
                    t = t.Remove(ti, 1);

            }

            return t.Length;
        }



        public int NumWaterBottles(int numBottles, int numExchange)
        {
            if (numBottles < numExchange)
                return numBottles;
            var total = numBottles;
            while (numBottles >= numExchange)
            {
                var rem = numBottles % numExchange;
                numBottles /= numExchange;
                total += numBottles;
                numBottles += rem;
            }


            return total;
        }


        //private int GetFullBottles(int numEmpty, int numExchange)
        //{
        //    if (numEmpty < numExchange)
        //        return 0;

        //    total += numEmpty / numExchange + GetFullBottles(numEmpty, numExchange);

        //    return total;
        //}





        public int NumTilePossibilities(string tiles)
        {
            int[] frequency = new int[26];
            foreach (var t in tiles)
            {
                frequency[t - 'A']++;
            }

            return dfs(frequency);
        }

        private int dfs(int[] frequency)
        {
            int sum = 0;

            for (int i = 0; i < 26; i++)
            {
                if (frequency[i] > 0)
                {
                    sum++;
                    frequency[i]--;
                    sum += dfs(frequency);
                    frequency[i]++;
                }
            }

            return sum;
        }



        //public int LengthLongestPath(string input)
        //{

        //}


        //var firstpart = true;

        //var secondindex = 0;
        //var count = 0;
        //for (var i = 0; i<S.Length; i++)
        //{
        //    if (S[i] == '-' && firstpart)
        //    {
        //        sb.Append(S.Substring(0,i+1));
        //        firstpart = false;
        //        secondindex = i + 1;
        //    }

        //    else
        //        if (S[i] != '-' && !firstpart && count<K)
        //        {
        //               sb.Append(S[i]);
        //               count++;
        //               // (count == K)
        //               //  count == 0;
        //        }
        //    else if (S[i] == '-' && !firstpart && count == K)
        //    {
        //        sb.Append(S[i]);
        //         count = 0;
        //    }


        //}
        //return sb.ToString().ToUpper();















        public TreeNode InvertTree(TreeNode root)
        {
            if (root == null)
                return null;

            (root.left, root.right) = (InvertTree(root.right), InvertTree(root.left));


            return root;

        }



        //best solution
        //public int TotalFruit(int[] tree)
        //{
        //    if (tree == null || tree.Length == 0) return 0;

        //    int start = 0;
        //    int end = 0;
        //    int k = 2;
        //    int maxFruits = 0;

        //    // Map to maintain the frequency count of each fruit
        //    Dictionary<int, int> fruitFreq = new Dictionary<int, int>();

        //    while (end < tree.Length)
        //    {
        //        if (!fruitFreq.ContainsKey(tree[end]))
        //        {
        //            fruitFreq.Add(tree[end], 0);
        //        }
        //        fruitFreq[tree[end]]++;

        //        // This is the important step as here we are reducing the count by removing the start elements.
        //        while (fruitFreq.Count > k)
        //        {
        //            fruitFreq[tree[start]]--;
        //            if (fruitFreq[tree[start]] == 0) fruitFreq.Remove(tree[start]);
        //            start++;
        //        }
        //        maxFruits = Math.Max(end - start + 1, maxFruits);
        //        end++;
        //    }
        //    return maxFruits;
        //}



        public int TotalFruit(int[] tree)
        {
            var allresults = new List<List<int>>();
          
            for (var i = 0; i < tree.Length; i++)
            {
          
                var dict = new Dictionary<int, int>();
                var result = new List<int>();
                for (var j = i; j < tree.Length; j++)
                {
                    if (!dict.ContainsKey(tree[j]))
                    {
                        if (dict.Count < 2)
                        {
                            dict.Add(tree[j], 1);
                            result.Add(tree[j]);
                        }
                        else
                            break;
                    }
                    else
                    {
                        result.Add(tree[j]);
                    }

                }

                allresults.Add(result);
            }

          


            var maxcount = allresults.Select(ar => ar.Count).Max();

            return maxcount;
        }



        public int NumUniqueEmails(string[] emails)
        {
            var len = emails.Length;
          //  var isdomain = false;
            var dict = new Dictionary<string, int>();
            for (var i = 0; i < len; i++)
            {
                var str = emails[i];
                for (var j = 0; j < str.Length; j++)
                {

                  //  if (!isdomain)
                  //  {
                        if (str[j] == '.')
                        {
                            str = str.Remove(j, 1);
                            j--;

                        }
                        else if (str[j] == '+')

                        {
                            var lentoremove = str.IndexOf('@') - j;
                            str = str.Remove(j, lentoremove);
                            j--;
                            //j -= lentoremove;
                        }
                        else if (str[j] == '@')
                        {
                            break; // isdomain = true;
                        }


                  //  }




                }
                if (!dict.ContainsKey(str))
                {
                    dict.Add(str, 1);
                }





            }

            return dict.Count;


        }




        public int BulbSwitch(int n)
        {
            checked
            {
                if (n <= 1)
                {
                    return n;
                }

                int res = 1;

                for (long i = 2; i * i <= n; i++)
                {
                    res++;
                }

                return res;
            }
        }


        //understand this one!!!!

         //   ::  redo from scratch!



        public int KEmptySlots(int[] bulbs, int k)
        {
            int res = Int32.MaxValue;
            int[] day = new int[bulbs.Length + 1];
            for (int i = 0; i < bulbs.Length; i++)
            {
                // day[i] is the day when the flower at position i blooms
                // day[0] is useless here
                day[bulbs[i]] = i + 1;
            }
           // var sync = "sdf";
           // sync.Remove()
            

            // we now are supposed to find a subarray of day[left, right] where its length is k+2 
            // and all i that left < i < right, we have day[i] > day[left] and day[i] > day[right]
            int left = 1, right = k + 2;
            for (int i = 2; right < day.Length; i++)
            {
                if (i == right)
                {
                    // found a sub array
                    res = Math.Min(res, Math.Max(day[left], day[right]));
                    left = i;
                    right = left + k + 1;
                }
                else if (day[i] < day[left] || day[i] < day[right])
                {
                    left = i;
                    right = left + k + 1;
                }
            }

            return (res == Int32.MaxValue) ? -1 : res;
        }
    


        public string NextClosestTime(string time)
        {
            var cur = 60 * Convert.ToInt32(time.Substring(0, 2));
            cur += Convert.ToInt32(time.Substring(3));

            var hash = new HashSet<int>();
            for (var i = 0; i < time.Length; i++)
            {
                if (time[i] != ':')
                    hash.Add(time[i] - '0');
            }

            while (true)
            {
                cur = (cur + 1)  % (24 * 60); 
                var hour1 = cur / 60 / 10;
                var hour2 = cur / 60 % 10;
                var min1 = cur % 60 / 10;
                var min2 = cur % 60 % 10;

                if (hash.Contains(hour1) && hash.Contains(hour2) && hash.Contains(min1) && hash.Contains(min2))
                {
                    var sb = new StringBuilder();
                    sb.Append(hour1);
                    sb.Append(hour2);
                    sb.Append(':');
                    sb.Append(min1);
                    sb.Append(min2);

                    

                    return sb.ToString();

                }

            }


            return "";
        }



        public int[] DailyTemperatures(int[] T)
        {
            var len = T.Length;
            var waitlist = new int[len];
            for (var i = 0; i < len; i++)
            {
                for (var j = i + 1; j < len; j++)
                {
                    if (T[j] > T[i])
                    {
                        waitlist[i] = j - i;
                        break;
                    }
                }
            }
            return waitlist;
        }

        public IList<int> MajorityElement(int[] nums)
        {
            var ocur = nums.Length / 3;
            var dict = new Dictionary<int, int>();

            
            var majority = new List<int>();
            for (var i = 0; i < nums.Length; i++)
            {
                if (dict.ContainsKey(nums[i]))
                {
                    dict[nums[i]]++;
                    if (dict[nums[i]] > ocur && !majority.Contains(nums[i]))
                    {
                        majority.Add(nums[i]);
                    }

                }
                else
                {
                    dict.Add(nums[i], 1);
                    if (dict[nums[i]] > ocur && !majority.Contains(nums[i]))
                    {
                        majority.Add(nums[i]);
                    }
                }
                    
            }
            return majority;


        }


        public TreeNode TrimBST(TreeNode root, int low, int high)
        {
            if (root == null)
                return null;
            if (root.val > high)
                return TrimBST(root.left, low, high);
            if (root.val < low)
                return TrimBST(root.right, low, high);

            root.left = TrimBST(root.left, low, high);
            root.right = TrimBST(root.right, low, high);
            return root;

        }







        public ListNode AddTwoNumbers6(ListNode l1, ListNode l2)
        {
            var s1 = new Stack<int>();
            var s2 = new Stack<int>();
            var carry = 0;
            var sum = 0;

            while (l1 != null)
            {
                s1.Push(l1.val);
                l1 = l1.next;
            }

            while (l2 != null)
            {
                s2.Push(l2.val);
                l2 = l2.next;
            }

            var sumstack = new Stack<int>();
            while (s1.Count > 0 || s2.Count > 0 || carry > 0)
            {
                sum = (s1.Count > 0 ? s1.Pop() : 0) + (s2.Count > 0 ? s2.Pop() : 0) + carry;
                carry = sum / 10;
                sum %= 10;

                sumstack.Push(sum);

            }


            var sumlist = new ListNode(sumstack.Pop());
            var head = sumlist;
            while (sumstack.Count > 0)
            {
                sumlist.next = new ListNode(sumstack.Pop());
                sumlist = sumlist.next;

            }

            return head;

        }



        //Efficient version:

        public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
        {
            var s1 = ListToStack(l1);
            var s2 = ListToStack(l2);

            var carry = 0;
            ListNode head = null;
            while (s1.Count > 0 || s2.Count > 0 || carry == 1)
            {
                var val1 = s1.Count > 0 ? s1.Pop() : 0;
                var val2 = s2.Count > 0 ? s2.Pop() : 0;
                var sum = val1 + val2 + carry;
                carry = sum / 10;
                sum = sum % 10;

                var node = new ListNode(sum);
                node.next = head;
                head = node;
            }

            return head;
        }


        private Stack<int> ListToStack(ListNode l)
        {
            var stack = new Stack<int>();
            while (l != null)
            {
                stack.Push(l.val);
                l = l.next;
            }
            return stack;
        }










        public string RemoveKdigits(string num, int k)
        {
            var len = num.Length;
            var stack = new Stack<char>();

            for (var i = 0; i < len; i++)
            {
                while (stack.Count > 0 & k > 0 && stack.Peek() > num[i])
                {
                    stack.Pop();
                    k--;
                }
                stack.Push(num[i]);

            }
            while (k > 0)
            {
                stack.Pop();
                k--;
            }



            var sb = new StringBuilder();
            while (stack.Count > 0)
            {
                sb.Insert(0, stack.Pop());
            }

            for (var j = 0; j < sb.Length; j++)
            {
                if (sb[j] > '0')
                    break;
                else
                {
                    sb.Remove(j, 1);
                    j--;
                }
            }

            if (sb.Length == 0)
                return "0";

            return sb.ToString();



        }


        public bool RepeatedSubstringPattern(string s)
        {
            if (s.Length <= 1)
                return false;
            var strtocheck = new StringBuilder();
            for (var i = 0; i < s.Length; i++)
            {
                strtocheck.Append(s[i]);
                var len = strtocheck.Length;
                if (s.Length % len > 0 || (i + 1 + len) > s.Length)
                    continue;
                var isrepeated = true;
                for (var j = i + 1; j + len <= s.Length; j += len)
                {

                    if (strtocheck.ToString() != s.Substring(j, len))
                    {
                        isrepeated = false;
                        break;
                    }
                }
                if (isrepeated == true)
                    return true;
            }
            return false;
        }









        //works!!  finds first peak!.  Takes into account lengths of 1, 2, and above.
        public int FindPeakElement(int[] nums)
        {
            //var b = "ab";
            //var a = new StringBuilder();
            //a.Append("a");
            //var c = a.Length;
            //if (a.t == b[0].ToString())
            //{

            //}

            var len = nums.Length;
            if (len == 1)
                return 0;
            var peak = 0;
            for (var i = 1; i < len; i++)
            {
                if (nums[i] > nums[i - 1] && ((i > len - 2) || nums[i] > nums[i + 1]))
                    peak = i;
            }
            return peak;
        }


        //works, with no 2nd function and 2 global vars

        TreeNode successor;
       // int sval;
        public TreeNode InorderSuccessor2(TreeNode root, TreeNode p)
        {
            //if (root == null)
            //    return null;
            //var diff = root.val - p.val;
            //if (diff > 0 && (overalldiff == 0 || diff < overalldiff))
            //{
            //    overalldiff = diff;
            //    successor = root;
            //}
            //if (root.val > p.val)
            //    InorderSuccessor2(root.left, p);
            //else
            //    InorderSuccessor2(root.right, p);

            //return successor;






            if (root == null)
                return null;
            var diff = root.val - p.val;
            if (diff > 0)
            {
                // sval = diff;
                successor = root;
                //  }

                //  if (diff > 0)
                InorderSuccessor(root.left, p);
            }
            else
                InorderSuccessor(root.right, p);


            return successor;








        }









        TreeNode successornode;

        public TreeNode InorderSuccessor(TreeNode root, TreeNode p)
        {
            var diff = Math.Abs(root.val - p.val);
            if (diff <= 0)
                diff = Int32.MaxValue;
            if (root.val != p.val && root.val > p.val)
                successornode = root;

            if (root.val <= p.val)
                Traverse(root.right, p.val, diff);
            else
                Traverse(root.left, p.val, diff);


           // Traverse(root, p.val, Math.Abs(root.val - p.val));
            return successornode;
        }

        private void Traverse(TreeNode node, int key, int successor)
        {
            if (node == null)
                return;
            var diff = Math.Abs(node.val - key);
            if (diff > 0 && diff < successor && node.val > key)
            {
                successor = Math.Abs(node.val - key);
                successornode = node;
            }
            if (node.val <= key)
                Traverse(node.right, key, successor);
            else
                Traverse(node.left, key, successor);

        }


       





        public void SortColors(int[] nums)
            {
                var len = nums.Length;
                var left = 0;
                var right = len - 1;
                for (var i = 0; i <= right; i++)
                {

                    if (nums[i] == 2)
                    {
                        (nums[i], nums[right]) = (nums[right], nums[i]);
                        right--;
                    i--;
                    }
                    else if (nums[i] == 0)
                    {
                        (nums[i], nums[left]) = (nums[left], nums[i]);
                        left++;
                       
                    }
                }
            }

        





        List<int> list1 = new List<int>();
        List<int> list2 = new List<int>();

        public bool LeafSimilar(TreeNode root1, TreeNode root2)
        {
            TraverseLeaf(root1, list1);
            TraverseLeaf(root2, list2);

            if (Enumerable.SequenceEqual(list1, list2))
                return true;
            else return false;
        }

        private void TraverseLeaf(TreeNode root, List<int> list)
        {
            if (root.left == null && root.right == null)
            {
                list.Add(root.val);
                return;
            }
            if (root.left != null)
                TraverseLeaf(root.left, list);
            if (root.right != null)
                TraverseLeaf(root.right, list);
        }






        







        public string DayOfTheWeek(int day, int month, int year)
        {
            var newdate = new DateTime(year, month, day);
            var dow = newdate.DayOfWeek;
            return dow.ToString();
        }



        public string LargestTimeFromDigits2(int[] arr)
        {
            //Array.Sort(arr);
            //var digits = arr .ToString();
            var digits = String.Concat(arr.OrderBy(x => x)); // arr.Select(x => x).OrderBy(x => x));
            var hora = DateTime.Parse("23:59");
            while (hora >= DateTime.Parse("00:00 AM"))
            {
                var newdig = String.Concat($"{hora:HH:mm}".Replace(":", "").OrderBy(x => x));
                if (newdig == digits) return $"{hora:HH:mm}";
                hora = hora.AddMinutes(-1);
            }
            return "";
        }


        public string LargestTimeFromDigits3(int[] arr)
        {
            var digits = String.Concat(arr.OrderBy(x => x));
            var maxtime = DateTime.Parse("23:59");

            while (maxtime >= DateTime.Parse("00:00"))
            {
                var newtime = String.Concat($"{maxtime:HH:mm}".Replace(":", "").OrderBy(x => x));
                if (newtime == digits)
                    return $"{maxtime:HH:mm}";
                maxtime = maxtime.AddMinutes(-1);
            }
            return "";

        }



        public bool IsOneBitCharacter(int[] bits)
        {
            if (bits.Length == 1)
                return true;
            var lastzero = false;
            for (var i = 0; i < bits.Length; i++)
            {
                if (bits[i] == 0)
                    lastzero = true;
                else
                {
                    lastzero = false;
                    i++;
                }
            }
            return lastzero;
        }
        public bool WordBreak2(string s, IList<string> wordDict)
        {
            if (s == null || s.Length == 0)
                return false;
           // var start = 0;
           // var end = 1;
            var hit = false;
           // var wd2 = new List<string>();
           // wd2.AddRange(wordDict);


            while (s.Length > 0)
            {
                foreach(var word in wordDict)
                {
                    var foundindex = s.IndexOf(word);
                    if (foundindex >= 0)
                    {
                        s = s.Remove(foundindex, word.Length);
                        hit = true;
                        if (s.Length == 0)
                            break;
                    }
                    else
                        hit = false;
                }
            }


            //while (end <= s.Length)
            //{
            //    if (wd2.Contains(s.Substring(start, end - start)))
            //    {
            //       // wd2.Remove(s.Substring(start, end - start));
            //        hit = true;
            //        start = end;
            //        end++;
            //    }

            //    else
            //    {
            //        hit = false;
            //        if (end == s.Length && hit == false)
            //            break;
            //        end++;
            //    }


            //}
            return hit;

        }



            public bool WordBreak(string s, IList<string> wordDict)
        {
            var dp = new bool[s.Length + 1];
            dp[0] = true;
            for (int i = 0; i < s.Length; i++)
                if (dp[i])
                    foreach (var dict in wordDict)
                        if (string.Compare(s, i, dict, 0, dict.Length) == 0)
                            dp[i + dict.Length] = true;
            return dp[s.Length];
        }


        public bool CheckInclusion(string s1, string s2)
        {
            if (s1.Length > s2.Length)
            {
                return false;
            }

            int[] s1Frequency = new int[26];


            for (int i = 0; i < s1.Length; i++)
            {
                s1Frequency[s1[i] - 'a']++;
            }


            int[] s2Frequency = new int[26];
            for (int i = 0; i < s2.Length; i++)
            {
                s2Frequency[s2[i] - 'a']++;
                if (i >= (s1.Length - 1))
                {
                    if (check(s1Frequency, s2Frequency))
                    {
                        return true;
                    }

                    s2Frequency[s2[i - (s1.Length - 1)] - 'a']--;
                }
            }

            return false;
        }

        private bool check(int[] a, int[] b)
        {
            for (int i = 0; i < 26; i++)
            {
                if (a[i] != b[i])
                {
                    return false;
                }
            }

            return true;
        }



        public bool CheckInclusionsucks(string s1, string s2)
        {
            if (string.IsNullOrWhiteSpace(s1) || string.IsNullOrWhiteSpace(s2))
                    return false;
            if (s1 == s2)
                return true;
            var len = s1.Length-1;
            var found = true;
            var start = s2.IndexOfAny(s1.ToCharArray()) ;
            s1.Remove(s2[start]);
            start++;
            if (start < s2.Length)
            {
                var i = start;
                while (len > 0 &&  i < s2.Length)
                {
                    if (!s1.Contains(s2[i]))
                    {
                        return false;
                    }
                    else
                    {

                    }

                    i++;
                    len--;
                }
                if (len == 0)
                    found = true;
            }

            return found;


        }



        //Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom
        public IList<int> RightSideView(TreeNode root)
        {
            var right = new List<int>();

            traverse(root, right, 1);

            return right;

        }


        private void traverse(TreeNode node, IList<int> rightnodes, int level)
        {
            if (node == null)
            {
                return;
            }
            if (level > rightnodes.Count)
                rightnodes.Add(node.val);

            if (node.right != null)
                traverse(node.right, rightnodes, level + 1);
            if (node.left != null)
                traverse(node.left, rightnodes, level + 1);

        }





        //Remove Duplicates from Sorted List
        //Given a sorted linked list, delete all duplicates such that each element appear only once.
        public ListNode DeleteDuplicates(ListNode head)
        {
            if (head == null)
                return null;
            var prev = head;
            var node = prev;
           
            while (node != null)
            {
                prev = node;
                node = node.next;
                while (node != null && prev.val == node.val)
                {
                    node = node.next;
                }
                prev.next = node; 

            }
            return head;
        }





        //Clone Graph
        //Given a reference of a node in a connected undirected graph.
        //    Return a deep copy (clone) of the graph.
        //   Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.

        //public class GraphNode
        //{
        //    public int val;
        //    public IList<GraphNode> neighbors;

        //    public GraphNode()
        //    {
        //        val = 0;
        //        neighbors = new List<GraphNode>();
        //    }

        //    public GraphNode(int _val)
        //    {
        //        val = _val;
        //        neighbors = new List<GraphNode>();
        //    }

        //    public GraphNode(int _val, List<GraphNode> _neighbors)
        //    {
        //        val = _val;
        //        neighbors = _neighbors;
        //    }
        //}



        //Dictionary<int, GraphNode> clonedict = new Dictionary<int, GraphNode>();
        //public GraphNode CloneGraph(GraphNode node)
        //{
        //    if (node == null) return null;
        //    if (clonedict.ContainsKey(node.val))
        //        return clonedict[node.val];
        //    GraphNode nd = new GraphNode(node.val);
        //    clonedict.Add(nd.val, nd);
        //    foreach (GraphNode n in node.neighbors)
        //        nd.neighbors.Add(CloneGraph(n));
        //    return nd;
        //}




        //Task Scheduler
        //Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task.Tasks could be done in any order.Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.
        //However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.
        //Return the least number of units of times that the CPU will take to finish all the given tasks.

        public int LeastInterval(char[] tasks, int n)
        {

            int maxFreq = 0, interval = 0, cnt = 0;
            int[] freq = new int[26];


            foreach (char t in tasks)
            {
                freq[t - 'A']++;

                // Find the most frequent task
                if (freq[t - 'A'] > maxFreq)
                {
                    maxFreq = freq[t - 'A'];
                    cnt = 1;
                }
                // Count the number of most frequent tasks
                else if (freq[t - 'A'] == maxFreq)
                    cnt++;
            }

            // maxFreq - 1: blocks needed to allocate the first maxFreq-1 most-frequent task
            // n + 1: each block needs n+1 spaces due the the cooling interval.
            // cnt: Size of last block = number of most-frequent tasks
            interval = (maxFreq - 1) * (n + 1) + cnt;

            return interval < tasks.Length ? tasks.Length : interval;
        }

        //Merge Intervals
        //Given a collection of intervals, merge all overlapping intervals.
        public int[][] Merge(int[][] intervals)
        {
            if (intervals == null || intervals.Length == 0)
                return new int[][] { };

            List<int[]> result = new List<int[]>();

            Array.Sort(intervals, (x, y) => x[0].CompareTo(y[0]));

            int s = intervals[0][0],
                e = intervals[0][1];

            for (int i = 1; i < intervals.Length; i++)
                if (e < intervals[i][0])
                {
                    result.Add(new int[] { s, e });

                    s = intervals[i][0];
                    e = intervals[i][1];
                }
                else
                    e = Math.Max(e, intervals[i][1]);

            result.Add(new int[] { s, e });

            return result.ToArray();
        }







        //Valid Parentheses
        //Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

        public bool IsValid(string s)
        {
            if (s.Length == 0)
            return true;
        Stack<char> stacky =
            new Stack<char>();
        Dictionary<char, char> dict =
            new Dictionary<char, char>();
        string parens = "(){}[]";
        for (int i = 0; i<parens.Length - 1; i+=2)
            dict.Add(parens[i + 1], parens[i]);

        foreach (char c in s){

            if (dict.ContainsKey(c)){
                //print($"at {c}, expecting {dict[c]}\n");
                if (stacky.Count == 0)
                    return false;
                char top = stacky.Pop();
                if (top != dict[c])
                    return false;
            }
            else{
                stacky.Push(c);
            }

        }

        return (stacky.Count == 0);

    }



        //Binary Tree Paths
        //Given a binary tree, return all root-to-leaf paths.

        public IList<string> BinaryTreePaths(TreeNode root)
        {
            var paths = new List<string>();
            traverse(root, "", paths);
            return paths;
        }

        private void traverse(TreeNode node, string path, IList<string> paths)
        {
            if (node == null)
                return;
            else if (node.left == null && node.right == null)
            {
                paths.Add(path + node.val);
                return;
            }
            else
            { 
                traverse(node.left, path + node.val + "->", paths);
                traverse(node.right, path + node.val + "->", paths);
            }
        }



        //Smallest Subtree with all the Deepest Nodes
        //Given the root of a binary tree, the depth of each node is the shortest distance to the root.
        //  Return the smallest subtree such that it contains all the deepest nodes in the original tree.
        //A node is called the deepest if it has the largest depth possible among any node in the entire tree.
        //The subtree of a node is tree consisting of that node, plus the set of all descendants of that node.


        public TreeNode SubtreeWithAllDeepest(TreeNode root)
        {
            // the idea is to apply post order traversal
            // if there are two children, both have same depth - return root
            // if one is bigger, than go to the bigger
            // recursive function is design to return depth from root to leaf node maximum path        
            var result = runPostOrderTraversal(root);
            return result.Item2;
        }

        ///  root 1, left 2, right 3, and right.right = 4
        private Tuple<int, TreeNode, int> runPostOrderTraversal(TreeNode root)
        {
            if (root == null)
            {
                return new Tuple<int, TreeNode, int>(0, null, 0);
            }

            // Left, right
            var left = runPostOrderTraversal(root.left); // 2
            var right = runPostOrderTraversal(root.right);

            var path1 = left.Item1;
            var path2 = right.Item1;

            if (path1 == path2)
            {
                return new Tuple<int, TreeNode, int>(path1 + 1, root, path1 + 1);
            }
            else if (path1 < path2)
            {
                return new Tuple<int, TreeNode, int>(path2 + 1, right.Item2, right.Item3);
            }
            else
                return new Tuple<int, TreeNode, int>(path1 + 1, left.Item2, left.Item3);
        }




        //Lowest Common Ancestor of a Binary Tree
        //Given a binary tree, find the lowest common ancestor(LCA) of two given nodes in the tree.
        //According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in 
        //T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

        public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)
        {
            var tuple = postOrderTraversal(root, p, q);
            return tuple.Item1;
        }

        /// <summary>
        /// return LCA and count of nodes found
        /// </summary>
        /// <param name="root"></param>
        /// <param name="p"></param>
        /// <param name="q"></param>
        /// <returns></returns>
        private static Tuple<TreeNode, int> postOrderTraversal(TreeNode root, TreeNode p, TreeNode q)
        {
            if (root == null)
            {
                return new Tuple<TreeNode, int>(null, 0);
            }

            var left = postOrderTraversal(root.left, p, q);
            if (left.Item1 != null)
            {
                return left;
            }

            var right = postOrderTraversal(root.right, p, q);
            if (right.Item1 != null)
            {
                return right;
            }

            int count = left.Item2 + right.Item2 + ((root == p || root == q) ? 1 : 0);
            if (count == 2)
            {
                return new Tuple<TreeNode, int>(root, 2);
            }

            return new Tuple<TreeNode, int>(null, count);
        }








        public ListNode MergeTwoLists3(ListNode l1, ListNode l2)
        {
            var node = new ListNode(0);
            var head = node;

            while (l1 != null && l2 != null)
            {
                if (l1.val <= l2.val)
                {
                    node.next = l1;
                    node = node.next;
                    l1 = l1.next;
                }
                else
                {
                    node.next = l2;
                    node = node.next;
                    l2 = l2.next;
                }
            }

            if (l1 != null)
                node.next = l1;
            else
                node.next = l2;

            return head.next;
        }




        //Interval List Intersections
        //Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.
        //Return the intersection of these two interval lists.
        //(Formally, a closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.
        //The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.For example, the intersection of[1, 3] and[2, 4] is [2, 3].)

        public int[][] IntervalIntersection(int[][] A, int[][] B)
        {
            List<int[]> result = new List<int[]>();
            int i = 0, j = 0;

            while (i < A.Length && j < B.Length)
            {
                int aStart = A[i][0], aEnd = A[i][1];
                int bStart = B[j][0], bEnd = B[j][1];

                if (aEnd >= bStart || bEnd >= aStart)
                {
                    int maxStart = Math.Max(aStart, bStart);
                    int minEnd = Math.Min(aEnd, bEnd);

                    if (maxStart <= minEnd)
                    {
                        result.Add(new int[] { maxStart, minEnd });
                    }

                    if (aEnd < bEnd)
                    {
                        i++;
                    }
                    else
                    {
                        j++;
                    }
                }
            }

            return result.ToArray();
        }



        //Course Schedule
        //There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.
        //Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
        //Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

        public bool CanFinish(int numCourses, int[][] prerequisites)
        {
            if (prerequisites.GetLength(0) == 0)
                return true;

            bool[] visited = new bool[numCourses];
            List<int>[] graph = new List<int>[numCourses];

            for (int i = 0; i <= numCourses - 1; i++)
                graph[i] = new List<int>();

            for (int i = 0; i <= prerequisites.GetLength(0) - 1; i++)
                graph[prerequisites[i][0]].Add(prerequisites[i][1]);

            for (int i = 0; i <= graph.Length - 1; i++)
                if (!visited[i])
                    if (!DFS(graph, visited, new bool[numCourses], i))
                        return false;

            return true;
        }

        private bool DFS(List<int>[] graph, bool[] visited, bool[] currentPath, int course)
        {
            if (currentPath[course])
                return false;

            visited[course] = true;
            currentPath[course] = true;

            for (int i = 0; i < graph[course].Count; i++)
                if (!DFS(graph, visited, currentPath, graph[course][i]))
                    return false;

            currentPath[course] = false;

            return true;

        }


        //Continuous Subarray Sum
        //Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, 
        //that is, sums up to n* k where n is also an integer.
        public bool CheckSubarraySum(int[] nums, int k)
        {
            int sum = 0;
            for (int i = 0; i < nums.Length - 1; i++)
            {
                sum = nums[i];
                for (int j = i + 1; j < nums.Length; j++)
                {
                    sum += nums[j];
                    if (sum == 0 && k == 0)
                        return true;

                    if (k != 0)
                    {
                        if (sum % k == 0)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }




        //Partition Equal Subset Sum
        //Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
        //    Note: Each of the array element will not exceed 100.
        //The array size will not exceed 200.


        public bool CanPartition(int[] nums)
        {
            var n = nums.Length;
            var sum = nums.Sum();

            if (sum % 2 != 0) return false;

            var target = sum / 2;

            if (nums.Contains(target)) return true;

            var dp = new bool[n + 1, target + 1];

            for (int i = 0; i <= n; i++)
            {
                dp[i, 0] = true;
            }

            for (int i = 1; i <= n; i++)
            {
                for (int j = 0; j <= target; j++)
                {
                    dp[i, j] = dp[i - 1, j];
                    if (j >= nums[i - 1])
                    {
                        dp[i, j] |= dp[i - 1, j - nums[i - 1]];
                    }
                }
            }

            return dp[n, target];
        }








        //Shortest Bridge
        //In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)
        //Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.
        //Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)

        int row;
        int col;
        public int ShortestBridge(int[][] A)
        {
            row = A.Length;
            if (row == 0) return 0;
            col = A[0].Length;

            var island1 = new List<int[]>();
            var island2 = new List<int[]>();

            for (int i = 0; i < row; i++)
            {
                for (int j = 0; j < col; j++)
                {
                    if (A[i][j] == 1 && island1.Count == 0)
                    {
                        Dfs(A, island1, i, j);
                    }
                    else
                    {
                        Dfs(A, island2, i, j);
                    }
                }
            }
            int min = 100;
            foreach (var i1 in island1)
            {
                foreach (var i2 in island2)
                {
                    min = Math.Min(min, Math.Abs(i1[0] - i2[0]) + Math.Abs(i1[1] - i2[1]) - 1);
                }
            }
            return min;
        }

        public void Dfs(int[][] A, List<int[]> island, int i, int j)
        {
            if (i < 0 || i >= row || j < 0 || j >= col || A[i][j] == 0) return;
            A[i][j] = 0;
            island.Add(new int[] { i, j });
            Dfs(A, island, i + 1, j);
            Dfs(A, island, i, j - 1);
            Dfs(A, island, i - 1, j);
            Dfs(A, island, i, j + 1);
        }





        //Serialize and Deserialize Binary Tree
        //Design an algorithm to serialize and deserialize a binary tree.There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree
        //can be serialized to a string and this string can be deserialized to the original tree structure.

        public string serialize(TreeNode root)
        {
            if (root == null) return "null";
            return root.val + " " + serialize(root.left) + " " + serialize(root.right);
        }


        public TreeNode deserialize(string data)
        {
            List<TreeNode> list = new List<TreeNode>();

            if (data == "null") return null;

            string[] words = data.Split(' ');
            TreeNode root = new TreeNode(Convert.ToInt32(words[0]));
            list.Add(root);

            bool goLeft = true;
            for (int i = 1; i < words.Count(); ++i)
            {
                if (words[i] == "null")
                {
                    if (goLeft) goLeft = false;
                    else list.RemoveAt(list.Count() - 1);
                }
                else
                {
                    TreeNode node = new TreeNode(Convert.ToInt32(words[i]));
                    if (goLeft)
                    {
                        list[list.Count() - 1].left = node;
                    }
                    else
                    {
                        list[list.Count() - 1].right = node;
                        list.RemoveAt(list.Count() - 1);
                    }
                    list.Add(node);
                    goLeft = true;
                }
            }

            return root;
        }


        //Valid Palindrome II
        //Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. 
        //works TOOO  SLOWW
        public bool ValidPalindrome(string s)
        {

            var r = new string( s.Reverse().ToArray());
            if (r == s)
                return true;
            for (var i = 0; i < s.Length; i++)
            {
                var palindrome = s.Remove(i, 1);
                var reversedpalindrome = new string( palindrome.Reverse().ToArray());
                if (palindrome == reversedpalindrome)
                    return true;
            }

            return false;


        }

        //WORKS GOOD:
        public bool ValidPalindrome2(string s)
        {
            if (s == null || s.Length <= 2)
            {
                return true;
            }
            char[] chars = s.ToCharArray();

            int l = 0, r = s.Length - 1;
            while (l < r)
            {
                if (chars[l] != chars[r])
                {
                    return isPalindrome(chars, l) || isPalindrome(chars, r);
                }
                l++;
                r--;
            }

            return true;

        }
        private bool isPalindrome(char[] s, int idx)
        {
            int l = 0, r = s.Length - 1;
            while (l < r)
            {
                if (l == idx)
                {
                    l++;
                }
                else if (r == idx)
                {
                    r--;
                }

                if (s[l] != s[r])
                {
                    return false;
                }
                l++;
                r--;
            }
            return true;
        }






        private int result1 = 0;
        private int[] nodes = null;

        public int CountComponents(int n, int[][] edges)
        {
            result1 = n;
            nodes = new int[n];

            for (int i = 0; i < n; i++)
                nodes[i] = i;

            foreach (var item in edges)
                Union(item[0], item[1]);

            return result1;
        }

        private void Union(int x, int y)
        {
            int px = Find(x),
                py = Find(y);

            if (px != py)
            {
                result1--;
                nodes[py] = px;
            }
        }

        private int Find(int x)
        {
            if (x != nodes[x])
                nodes[x] = Find(nodes[x]);

            return nodes[x];
        }


        public class BoolNode
        {
            public bool val;
            public Node next;
            public Node random;

            public BoolNode(bool _val)
            {
                val = _val;
                next = null;
                random = null;
            }
        }

        //n-ary Tree with each node having a boolean flag.Traverse all the nodes with only boolean flag = True.Return the total distance traveled from root to all those nodes.
        //int traverseNodes(BoolNode node)
        //{
        //    if (node.val == false)
        //        return 0;

        //    int result = 1;
        //    for (int i = 0; i < node->subnodes.size(); ++i)
        //    {
        //        result += traverseNodes(node->subnodes[i]);
        //    }
        //    return result;
        //}




        //Question 0. Similar strings ("face", "eacf") returns true if only 2 positions in the strings are swapped. Here 'f' and 'e' are swapped in the example.
        public bool areSimilar(string a, string b)
        {
            if (a.Length != b.Length)
                return false;
            int diffCount = 0;
            int[] diffIndices = new int[2];
            for (int i = 0; i < a.Length; ++i)
            {
                if (a[i] != b[i])
                {
                    if (diffCount == 2)
                        return false;
                    diffIndices[diffCount++] = i;
                }
            }
            return diffCount == 0 || (diffCount == 2 &&
                a[diffIndices[0]] == b[diffIndices[1]] &&
                a[diffIndices[1]] == b[diffIndices[0]]);
        }





        //Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.

        Random random = new Random();
        int[] nums;

        //public Solution(int[] nums)
        //{
        //    this.nums = nums;
        //}

        public int Pick(int target)
        {
            var candidate = -1;
            var n = nums.Length;

            var count = 0;
            for (int i = 0; i < n; i++)
            {
                if (nums[i] != target) continue;

                count++;

                var randomIndex = random.Next(count);
                if (randomIndex == 0)
                {
                    candidate = i;
                }
            }
            return candidate;
        }






        //Given a non-empty array of digits representing a non-negative integer, increment one to the integer.
        //The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.
        //You may assume the integer does not contain any leading zero, except the number 0 itsel

        public int[] PlusOne(int[] digits)
        {
            
            var results = new List<int>();
            
            var carry = 1;
            var sum = 0;
            for (var i = digits.Length - 1; i >= 0; i--)
            {
                sum = digits[i] + carry;
                carry = sum / 10;
                sum %= 10;
                results.Add(sum);
            }
            if (carry == 1)
                results.Add(1);

            results.Reverse();
            return results.ToArray();

        }

        //Minimum Remove to Make Valid Parentheses
        //Given a string s of '(' , ')' and lowercase English characters.
        //Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions) so that the resulting parentheses string is valid and return any valid string.
        //Case study
        //In order for me to solve the algorithm, I learn that I have to put two test cases into consideration.
        //Case 1: lee(t(c) o)de)
        //The idea is to use stack to store all indexes of open paretheses, and if there is ')', then remove matched open parethese.Otherwise replace stringbuilder temporary variable copy - a copy of string - using placeholder char* at index of ')'. We can name it "replace unmatched close parenthese with wildchar *".
        //lee(t(c) o)de) -> lee(t(c) o)de* -> remove* in the string.
        //put '(' in stack, and if there is matched ')', then pop '(' otherwise replace stringBuilder index position with '*'.

        public String MinRemoveToMakeValid(String s)
        {

            var sb = new StringBuilder(s);
            var stack = new Stack<int>();

            var length = s.Length;
            for (int i = 0; i < length; i++)
            {
                var current = s[i];
                var isOpen = current == '(';
                var isClose = current == ')';

                if (isOpen)
                {
                    stack.Push(i);
                }

                if (isClose)
                {
                    if (stack.Count > 0)
                    {
                        stack.Pop();
                    }
                    else
                    {
                        sb.Replace(')', '*', i, 1);
                    }
                }
            }

            // remove extract ((, for example ))((
            while (stack.Count > 0)
            {
                sb.Remove(stack.Pop(), 1);
            }

            return sb.Replace("*", "", 0, sb.Length).ToString();



        }



        //Alien Dictionary 
        //There is a new alien language which uses the latin alphabet.However, the order among letters are unknown to you.You receive a list of non-empty
        //words from the dictionary, where words are sorted lexicographically by the rules of this new language.Derive the order of letters in this language.

        public string AlienOrdersucks(string[] words)
        {
            var len = 0;
            foreach (var word in words)
            {
                len = word.Length > len ? word.Length : len;
            }

            var order = new HashSet<char>();
            order.Add(words[0][0]);

            for (var letter = 0; letter < len; letter ++)
            {
                for (var word = 0; word < len; word++)
                {
                    if (letter < words[word].Length && letter < words[word+1].Length && words[word][letter] != words[word+1][letter]
                        && !order.Contains(words[word + 1][letter]))
                    {
                        order.Add(words[word+1][letter]);
                    }
                }
            }
            return new string ( order.Select(o => o).ToArray());
        }



            public string AlienOrder(string[] words)
        {


            var queue = new Queue<char>();
            var graph = new Dictionary<char, List<char>>();
            var indegree = new Dictionary<char, int>();
            var result = new StringBuilder();

            // Build graph and ingergee
            foreach (var word in words)
            {
                foreach (var c in word)
                {
                    if (!graph.ContainsKey(c)) { graph.Add(c, new List<char>()); }
                    if (!indegree.ContainsKey(c)) { indegree.Add(c, 0); }
                }
            }

            // Iterate by words to initialize graph and indegree
            for (var i = 1; i < words.Length; i++)
            {
                var word1 = words[i - 1];
                var word2 = words[i];

                if (word1.Length > word2.Length && word1.StartsWith(word2)) { return String.Empty; }

                for (var j = 0; j < Math.Min(word1.Length, word2.Length); j++)
                {
                    if (word1[j] != word2[j])
                    {
                        // Add relation
                        graph[word1[j]].Add(word2[j]);

                        // Increase indegree
                        indegree[word2[j]]++;
                        break;
                    }
                }
            }

            // Add chars with 0 indegree to queue
            foreach (KeyValuePair<char, int> kv in indegree)
            {
                if (kv.Value == 0)
                {
                    queue.Enqueue(kv.Key);
                }
            }

            // BFS
            while (queue.Any())
            {
                var vertex = queue.Dequeue();

                foreach (var c in graph[vertex])
                {
                    if (--indegree[c] == 0)
                    {
                        queue.Enqueue(c);
                    }
                }

                result.Append(vertex);
            }

            return result.Length == indegree.Count ? result.ToString() : String.Empty;


        }






        //Kth Smallest Element in a BST
        //Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

        public int KthSmallest(TreeNode root, int k)
        {
            return helper(root, ref k);
        }

        int helper(TreeNode root, ref int k)
        {
            if (root == null) return -1;
            int x = helper(root.left, ref k);
            if (k == 0) return x;
            if (--k == 0) return root.val;
            return helper(root.right, ref k);
        }

        //Range Sum of BST
        //Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R(inclusive).
        //The binary search tree is guaranteed to have unique values.

        public int RangeSumBST(TreeNode root, int L, int R)
        {
            if (root == null)
                return 0;
            return (root.val >= L && root.val <= R ? root.val : 0) + RangeSumBST(root.left, L, R) + RangeSumBST(root.right, L, R);
        }


        ///find-index-maximum-occurring-element-equal-probability/*
        ///
        //Facebook have a practice of asking problems on Random and Reservoir Sampling.
        //This problem relates to Reservoir Sampling.
        //It should be solved with O(1) space and time O(N).
        //Hence, any solution beyond would be considered by interviewer as failed.

        public void maxRandomIndex(int[] nums)
        {
            Random random = new Random();

            int max = int.MinValue;
            int maxIndex = -1;

            int count = 0;

            for (int i = 0; i < nums.Length; i++)
            {
                if (nums[i] > max)
                {
                    max = nums[i];
                    maxIndex = i;
                    count = 1;
                }
                else if (nums[i] == max)
                {
                    count++;

                    // probability of 1/count
                    if (random.Next(count) == 0)
                    {
                        maxIndex = i;
                    }
                }

                Console.Write(maxIndex + " ");
            }
        }









        //See code in MAIN on how to call it!!
        //Facebook interview onsite
        //You are given a mn grid.You are asked to generate k mines on this grid randomly. Each cell should have equal probability of k / mn of being chosen. Your algorithm should run in O(m) time.
        public void generateKMines(char[][] grid, int K)
        {
            int m = grid.Length, n = grid[0].Length;
            int count = 0;
            Random random = new Random();
            while (count != K)
            {
                int index = random.Next(m * n);
                int i = index % m, j = index % n;
                if (grid[i][j] != 'X')
                {
                    grid[i][j] = 'X';
                    count++;
                }

            }
        }



        public string AddBinary(string a, string b)
        {
            var aindex = a.Length - 1;
            var bindex = b.Length - 1;
            var carry = 0;
            var sum = 0;
            var total = new StringBuilder();
            while (aindex >= 0 || bindex >= 0 || carry == 1)
            {
                sum = (aindex < 0 ? 0 : a[aindex] - '0') + (bindex < 0 ? 0 : b[bindex] - '0') + carry;
                carry = sum / 2;
                sum %= 2;
                total.Insert(0, sum);
                aindex--;
                bindex--;

            }
            return total.ToString();
        }


        //Valid Palindrome
        //Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
        //Note: For the purpose of this problem, we define empty string as valid palindrome.
        public bool IsPalindrome2(string s)
        {
            var clean = new StringBuilder();
            for (var i = 0; i < s.Length; i++)
            {
                if (char.IsLetterOrDigit(s[i]))
                    clean.Append(char.ToLower(s[i]));
            }

            var reversed = new string(clean.ToString().Reverse().ToArray());

            if (clean.ToString() == reversed)
                return true;
            else
                return false;
        }




        public string AddStrings(string num1, string num2)
        {
            if (string.IsNullOrWhiteSpace(num1) || string.IsNullOrWhiteSpace(num2))
                return string.Empty;
            var len1 = num1.Length - 1;
            var len2 = num2.Length - 1;

            var sum = 0;
            var carry = 0;
            var total = new StringBuilder();
            while (len1 >= 0 || len2 >= 0 || carry == 1)
            {
                sum = (len1 < 0 ? 0 : num1[len1] - '0') + (len2 < 0 ? 0 : num2[len2] - '0') + carry;
                carry = sum / 10;
                sum %= 10;
                total.Insert(0,sum);
                len1--;
                len2--;

            }

            return total.ToString();



        }

        //  Minimum Window Substring
        //  Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
        public string MinWindowNotMine(string s, string t)  //  FAST!!!  - LEARN THISS ONE!!!!!
        {
            if (string.IsNullOrEmpty(s) || string.IsNullOrEmpty(t))
            {
                return string.Empty;
            }

            var map = new int[128];
            //Array.Clear(map, 0, map.Length);
            foreach (var ch in t)
            {
                map[ch]++;
            }


            int j;
            int i; // the "tail" of current sub string. [j..i] makes a string "window".
            int start = -1; // the start position of the best sub string we found so far
            int min = int.MaxValue; // the length of the best sub string we found so far
            var total = t.Length;

            for (i = 0, j = 0; i < s.Length; i++)
            {
                if (map[s[i]]-- > 0)
                {
                    total--;
                }

                /*
                when "total" reduced to 0, we know we have found a candidate. we compare the candidate
                with the bast result we found so far. If the new candidate is better, update the "best".
                */
                while (total == 0)
                {
                    var length = i - j + 1;
                    if (length < min)
                    {
                        min = length;
                        start = j;
                    }

                    /*
                    Is the candidate we found a good one? In most cases it is not.
                    Let's say we have a template string:
                    "ABC" 
                    and a data string:
                    "XYZ..(other characters but none of them are 'A', 'B' or 'C')....ABC"
                    Based on the algorithm above, we start from j=0 and i=0. Keep moving i until we 
                    fond a candidate. In this case, the first one we found is the whole string. 
                    Is it a good one? Of cause it is not. The reason is that we have lot of "garbage" 
                    characters before we found the right pattern. In another words, we need to move 
                    variable "j" to right until we get rid of them. Then the question is: How do i 
                    know it is a "garbage" character? As we know, while variable moving from left to 
                    right, we reduce the corresponding value in map time to times. If it is a character
                    in template, it must be greater than 0. This could be a good indicator. However,
                    how about a sub string like below?
                    .....A.......XYZ............ABC......
                                 j                i
                    in this case, the first 'A' was used so the value in map is already -1. How do we
                    know the 'A' is in template? Of cause we can scan the template string but that is 
                    not a smart idea because it is slow. it is O(m * n).
                    So why don't we recover the value? Say, every time the "j" moves, we increase the 
                    corresponding value in map by 1. By doing so, the corresponding value in map will 
                    be restored to the original data: if a character is not in template string the 
                    value will be 0 otherwise it will be the number it appears in the template string.
                    What really means when a value in map change from 0 to 1? or even higher? That not
                    only means we found a character which in template string but also means we lost 
                    a required character from previous [j..i] windows. i.e, the candidate [j..i] 
                    changed to [j-1...i] and it is not valid any more because we kicked out a required
                    character. What we should do? Well, keep moving "i" to find next one.
                    */
                    if (++map[s[j++]] > 0)
                    {
                        total++;
                    }
                }
            }

            // We done. return the result if we found one
            return (min == int.MaxValue) ? string.Empty : s.Substring(start, min);
        }


        public IList<int> FindAnagrams2(string s, string p)
        {
            var results = new List<int>();
            if (s == null || s.Length == 0)
                return results;

            var charcounts = new int[26];
            var left = 0;
            var right = 0;
            var count = p.Length;

            for (var i = 0; i < p.Length; i++)
            {
                charcounts[p[i] - 'a']++;
            }

            while (right < s.Length)
            {

                if (charcounts[s[right++] - 'a']-- >= 1)
                    count--;

                if (count == 0)
                    results.Add(left);

                if (right - left == p.Length && charcounts[s[left++] - 'a']++ >= 0)
                    count++;

            }



            return results;
        }

        //too slow
        public IList<int> FindAnagrams(string s, string p)
        {
            var foundindexes = new List<int>();
            if (string.IsNullOrWhiteSpace(s) || s.Length < p.Length)
                return foundindexes;
            var len = s.Length;
            var left = 0;

            var count = p.Length;
            var right = 0;
            var foundchars = new StringBuilder(p);

            while (right < len)
            {


                var found = foundchars.ToString().IndexOf(s[right]);
                if (found > -1)
                {
                    foundchars = foundchars.Remove(found, 1);
                    if (foundchars.Length == 0)
                    {
                        foundindexes.Add(left);
                        left++;
                        right = left;
                        foundchars.Append(p);
                    }
                    else
                    {
                        right++;

                    }
                }
                else
                {
                    if (!p.Contains(s[right]))
                    {
                        left = right;
                        foundchars.Clear();
                        foundchars.Append(p);
                    }
                    else
                    {
                        left++;
                        right = left;
                    }

                }

            }
            return foundindexes;
        }


        public int RemoveDuplicates(int[] nums)
        {
            var uniques = nums.GroupBy(n => n).ToDictionary(n => n.Key, n => n.Count()).Select(n => n.Key);
            var dict = nums.GroupBy(n => n).ToDictionary(n => n.Key, n => n.Count());
            var len = uniques.Count();
            var i = 0;
            foreach (var u in uniques)
            {
                nums[i] = u;
                i++;
            }


            //for (var i = 0; i < nums.Length; i++)
            //{
            //    if (i == nums.Length-1)
            //    {
            //        uniques.Add(i);
            //    }
            //    else if (i < nums.Length -1 && nums[i] == nums[i + 1])
            //    {
            //        len--;
            //        uniques.Add(i);
            //      //  i++;
            //    }
            //    else
            //        uniques.Add(i);


            //}

            //var j = 0;
            //foreach(var unique in uniques)
            //{
            //    nums[j] = nums[unique];
            //    j++;
            //}

            return len;
        }




        public int MyAtoi2(String str)
        {
            int i = 0;
            int sign = 1;
            int result = 0;
            if (str.Length == 0) return 0;

            //Discard whitespaces in the beginning
            while (i < str.Length && str[i] == ' ')
                i++;

            // Check if optional sign if it exists
            if (i < str.Length && (str[i] == '+' || str[i] == '-'))
                sign = (str[i++] == '-') ? -1 : 1;

            // Build the result and check for overflow/underflow condition
            while (i < str.Length && str[i] >= '0' && str[i] <= '9')
            {
                if (result > int.MaxValue / 10 ||
                        (result == int.MaxValue / 10 && str[i] - '0' > int.MaxValue % 10))
                {
                    return (sign == 1) ? int.MaxValue : int.MinValue;
                }
                result = result * 10 + (str[i++] - '0');
            }
            return result * sign;
        }

        public int MyAtoi(string str)
        {
            var s = new Stack<char>();
            var numeric = false;
            var negative = false;
            var positive = false;

            try
            {

                for (var i = 0; i < str.Length; i++)
                {
                    if (str[i] >= '0' && str[i] <= '9')
                    {
                        if (!numeric && str[i] == '0' && i < str.Length - 1 && str[i + 1] < '0' && str[i + 1] > '9')
                            continue;
                        else
                        {
                            s.Push(str[i]);
                            numeric = true;
                        }
                    }
                    else if (str[i] != '-' && str[i] != '+' && str[i] != ' ')
                    {
                        if (numeric)
                            break;
                        else
                            return 0;
                    }

                    else if (str[i] == ' ')
                    {
                        if (numeric)
                            break;
                        else if (positive || negative)
                            return 0;

                    }
                    else if (str[i] == '+')
                    {

                        if (numeric)
                            break;
                        if (positive && !numeric)
                            return 0;
                        if (negative && !numeric)
                            return 0;
                        positive = true;
                    }
                    else if (str[i] == '-')
                    {
                        if (numeric)
                            break;
                        if (negative && !numeric)
                            return 0;
                        if (negative)
                            break;

                        if (positive && !numeric)
                            return 0;
                        negative = true;
                    }

                    else if (str[i] == '.')
                    {
                        break;
                    }
                }


                var outint = 0;
                var multiplier = 1;
                while (s.Count > 0)
                {
                    var test = checked(outint += ((s.Pop() - '0') * multiplier));
                    if (s.Count > 0)
                        test = checked(multiplier *= 10);
                }
                return negative ? outint * -1 : outint;

            }
            catch (OverflowException)
            {
                return negative ? int.MinValue : int.MaxValue;
            }

        }

        public int LengthOfLongestSubstring2(string s)
        {
            var set = new HashSet<char>();
            var left = 0;
            var right = 0;
            var length = 0;



            while (right < s.Length)
            {
                if (!set.Contains(s[right]))
                {
                    set.Add(s[right]);
                    length = Math.Max(length, set.Count);
                    right++;
                }
                else
                {
                    set.Remove(s[right]);
                    left++;
                }
            }

            return length;


        }

        public void ReorderList2(ListNode head)
        {
            if (head == null)
                return;
            var s = new Stack();
            var temp = head;
            var count = 0;
            while (temp != null)
            {
                s.Push(temp);
                temp = temp.next;
                count++;
            }

            temp = head.next;
            count--;
            while (count > 0)
            {
                head.next = s.Pop() as ListNode;
                head = head.next;
                count--;
                if (count == 0)
                    break;
                head.next = temp;
                head = head.next;
                temp = temp.next;
                count--;

            }
            head.next = null;
        }





        Dictionary<Node, Node> dict = new Dictionary<Node, Node>();

        public Node CopyRandomList(Node head)
        {
            if (head == null)
                return null;

            if (dict.ContainsKey(head))
            {
                return dict[head];
            }
            else
            {

                var node = new Node(head.val);
                dict.Add(head, node);

                node.next = CopyRandomList(head.next);
                node.random = CopyRandomList(head.random);
                return node;
            }
        }

        public static int[] TwoNumberSum(int[] array, int targetSum)
        {
            // Write your code here.
            var target = new List<int>();
            for (var i = 0; i < array.Length; i++)
            {
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (i != j && array[i] + array[j] == targetSum)
                    {
                        var found = new int[] { array[i], array[j] };

                        return found;
                    }
                }
            }
            return new int[0];
        }

        public uint reverseBits2(uint n)
        {
            var nstr = Convert.ToString(n, 2).PadLeft(32, '0');
            var reversed = nstr.Reverse();
            var reverseduint = Convert.ToUInt32(new string(reversed.ToArray()), 2);
            return reverseduint;

        }

        public int[] CountBits2(int num)
        {

            var bits = new List<int>();
            for (var i = 0; i <= num; i++)
            {
                bits.Add(NumberOfSetBits(i));

            }
            return bits.ToArray();




        }



        int NumberOfSetBits(int i)
        {
            i = i - ((i >> 1) & 0x55555555);
            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
            return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
        }









        public string RemoveOuterParentheses(string S)
        {

            var count = 0;
            var start = 0;
            var newstring = new StringBuilder();
            for (var i = 0; i < S.Length; i++)
            {
                if (S[i] == '(')
                    count++;
                if (S[i] == ')')
                {
                    count--;
                    if (count == 0)
                    {
                        newstring.Append(S.Substring(start + 1, i - 1 - start));
                        start = i + 1;
                    }
                }
            }
            return newstring.ToString();
        }

        public ListNode AddTwoNumbers5(ListNode l1, ListNode l2)
        {
            var node = new ListNode(0);
            var head = node;
            var carry = 0;
            while (l1 != null || l2 != null || carry == 1)
            {
                var sum = (l1?.val ?? 0) + (l2?.val ?? 0) + carry;
                carry = sum / 10;
                sum %= 10;
                node.next = new ListNode(sum);
                node = node.next;
                //if (l1 != null)
                l1 = l1?.next;
                //if (l2 != null)
                l2 = l2?.next;


            }
            return head.next;

        }



      










        public int RomanToInt(string s)
        {
            var len = s.Length;
            var sum = 0;
            for (var i = 0; i < len; i++)
            {
                if (s[i] == 'I')
                {
                    if (i < len - 1 && s[i + 1] == 'V')
                    {
                        sum += 4;
                        i++;
                    }
                    else if (i < len - 1 && s[i + 1] == 'X')
                    {
                        sum += 9;
                        i++;
                    }
                    else
                    {
                        sum++;
                    }
                }

                else if (s[i] == 'X')
                {
                    if (i < len - 1 && s[i + 1] == 'L')
                    {
                        sum += 40;
                        i++;
                    }
                    else if (i < len - 1 && s[i + 1] == 'C')
                    {
                        sum += 90;
                        i++;
                    }
                    else
                    {
                        sum += 10;
                    }
                }


                else if (s[i] == 'C')
                {
                    if (i < len - 1 && s[i + 1] == 'D')
                    {
                        sum += 400;
                        i++;
                    }
                    else if (i < len - 1 && s[i + 1] == 'M')
                    {
                        sum += 900;
                        i++;
                    }
                    else
                    {
                        sum += 100;
                    }
                }

                else if (s[i] == 'V')
                {
                    sum += 5;
                }
                else if (s[i] == 'L')
                {
                    sum += 50;
                }
                else if (s[i] == 'D')
                {
                    sum += 500;
                }

                else if (s[i] == 'M')
                {
                    sum += 1000;
                }

            }
            return sum;
        }

        public int MissingElement(int[] nums, int k)
        {
            var count = 0;
            var missing = 0;



            for (var i = 0; count < k && i < nums.Length - 1; i++)
            {
                var diff = nums[i + 1] - nums[i];
                if (diff > 1)
                {
                    if (count + diff - 1 >= k)
                    {
                        missing = nums[i] + k - count;
                    }
                    count += diff - 1;

                }

            }

            if (count < k)
                missing = nums[nums.Length - 1] + k - count;


            return missing;
        }







        public int NetworkDelayTime(int[][] times, int N, int K)
        {



            if (times == null || times.Length == 0 || N == 0 || K > N || K < 1)
            {
                return -1;
            }

            int[] paths = new int[N + 1];
            int inf = 20000;
            Array.Fill(paths, inf);

            paths[K] = 0;

            while (N-- > 1)
            {
                foreach (int[] edge in times)
                {
                    int newTime = paths[edge[0]] + edge[2];

                    if (newTime < paths[edge[1]])
                    {
                        paths[edge[1]] = newTime;
                    }
                }
            }

            int result = -1;

            for (int i = 1; i < paths.Length; ++i)
            {
                if (paths[i] == inf)
                    return -1;

                result = Math.Max(result, paths[i]);
            }

            return result;
        }

        public int GetSum2(int a, int b)
        {
            if (b == 0)
                return a;
            return GetSum2(a ^ b, (a & b) << 1);
        }




        public int MaxSubArrayLen2(int[] nums, int k)
        {
            var sum = 0;
            var maxlen = 0;
            var dict = new Dictionary<int, int>() { { 0, -1 } };

            for (var i = 0; i < nums.Length; i++)
            {
                sum += nums[i];


                if (dict.ContainsKey(sum - k))
                    maxlen = Math.Max(maxlen, i - dict[sum - k]);

                if (!dict.ContainsKey(sum))
                    dict.Add(sum, i);

            }

            return maxlen;


        }


        Dictionary<int, int> largest = new Dictionary<int, int>();


        public IList<int> LargestValues(TreeNode root)
        {
            var largestlist = new List<int>();
            FindLargest(root, 1);
            return largest.Select(l => l.Value).ToList();
        }

        private void FindLargest(TreeNode root, int level)
        {

            if (root == null)
                return;

            if (!largest.ContainsKey(level))
                largest[level] = root.val;
            else if (root.val > largest[level])
                largest[level] = root.val;

            level++;
            FindLargest(root.left, level);
            FindLargest(root.right, level);

        }







        public string ReverseVowels(string s)
        {
            var sb = new StringBuilder(s);
            var reversed = s.ToList();
            var vowels = new char[] { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
            var left = 0;
            var right = s.Length - 1;


            while (left < right)
            {


                left = sb.ToString().IndexOfAny(vowels, left);
                if (left == -1)
                    break;
                //return new string(reversed.ToArray());
                right = sb.ToString().LastIndexOfAny(vowels, right);
                if (right == -1)
                    break; // return new string(reversed.ToArray());


                (reversed[left], reversed[right]) = (reversed[right], reversed[left]);
                sb[left] = ' ';
                sb[right] = ' ';
                left++;
                right--;

            }
            return new string(reversed.ToArray());

        }



        public int LeftMostColumnWithOne(int[][] binaryMatrix) // BinaryMatrix binaryMatrix)
        {
            //var dims = binaryMatrix.Dimensions();
            var rows = 2;// dims[0];
            var cols = 4; // dims[1];
            var pos = cols;

            for (var row = 0; row < rows; row++)
            {
                var low = 0;
                var high = cols - 1;
                while (low <= high)
                {
                    var mid = low + (high - low) / 2;
                    var midval = binaryMatrix[row][mid];
                    if (midval == 0)
                        low = mid + 1;
                    else
                        high = mid - 1;

                }
                pos = Math.Min(low, pos);

            }

            return pos == cols ? -1 : pos;


        }


        public int DaysBetweenDates(string date1, string date2)
        {
            var d1 = Convert.ToDateTime(date1);
            var d2 = Convert.ToDateTime(date2);

            //while (true)
            //{

            //}
            // ...


            return (d2 - d1).Days;
        }



        public int ClosestValue(TreeNode root, double target)
        {
            return FindClosest(root, target, root.val);
        }

        private int FindClosest(TreeNode root, double target, int closest)
        {
            if (root == null)
                return closest;



            if (Math.Abs(root.val - target) < Math.Abs(closest - target))
                closest = root.val;

            if (root.val > target)
                return FindClosest(root.left, target, closest);
            else return FindClosest(root.right, target, closest);

        }



        public string SimplifyPath(string path)
        {
            if (path.Length == 0)
                return path;
            var parts = path.Split('/', StringSplitOptions.RemoveEmptyEntries).ToList();



            var level = 0;
            for (var i = 0; i < parts.Count; i++)
            {
                if (parts[i] == "..")
                {
                    if (parts.Count > 0)
                    {
                        parts.RemoveAt(i);
                        i--;
                        if (parts.Count > 0 && i >= 0)
                        {
                            parts.RemoveAt(i);
                            i--;
                        }

                    }
                    else
                        level++;
                }
                else if (parts[i] == ".")
                {
                    parts.RemoveAt(i);
                    i--;
                }



            }


            var outpath = "/" + String.Join("/", parts);
            return outpath;

        }


        public int[] NextGreaterElement(int[] nums1, int[] nums2)
        {

            var result = new int[nums1.Length];
            for (var i = 0; i < nums1.Length; i++)
            {
                var foundindex = Array.IndexOf(nums2, nums1[i]);
                {
                    if (foundindex == nums2.Length - 1)
                        result[i] = -1;
                    else
                    {
                        var foundnextindex = Array.FindIndex(nums2, foundindex, n => n > nums1[i]);
                        result[i] = foundnextindex == -1 ? -1 : nums2[foundnextindex];
                    }

                }
            }
            return result;
        }


        public int[] NextGreaterElement2(int[] nums1, int[] nums2)
        {

            var a = Array.FindIndex(nums2, 3, a => a > 2);
            // var a = nums2.Where(n => n > 4).First();

            if (nums1 == null || nums1.Length == 0)
                return new int[] { };
            var outarray = new int[nums1.Length];
            var l2 = nums2.ToList();
            for (var i = 0; i < nums1.Length; i++)
            {
                var num = l2.IndexOf(nums1[i]);
                if (num < 0)
                    outarray[i] = -1;
                else
                {
                    var value = l2.Skip(num + 1).Where(n => n > nums1[i]).FirstOrDefault();
                    if (value > nums1[i])
                        outarray[i] = value;
                    else
                        outarray[i] = -1;
                }
            }
            return outarray;
        }







        public IList<int> ArraysIntersection(int[] arr1, int[] arr2, int[] arr3)
        {
            var maxlen = Math.Max(Math.Max(arr1.Length, arr2.Length), arr3.Length);

            var dict1 = arr1.ToDictionary(v => v, v => 1); // new Dictionary<int, int>();
            var dict2 = new Dictionary<int, int>();
            var dict3 = new Dictionary<int, int>();

            for (var i = 0; i < maxlen; i++)
            {
                if (i < arr1.Length && !dict1.ContainsKey(arr1[i]))
                {
                    dict1.Add(arr1[i], 1);
                }


                if (i < arr2.Length && !dict2.ContainsKey(arr2[i]))
                {
                    dict2.Add(arr2[i], 1);
                }

                if (i < arr3.Length && !dict3.ContainsKey(arr3[i]))
                {
                    dict3.Add(arr3[i], 1);
                }
            }


            var merged = dict1.Concat(dict2).Concat(dict3).GroupBy(d => d.Key)
                .ToDictionary(d => d.Key, d => d.Count()).Where(d => d.Value >= 3)
                .Select(d => d.Key).ToList();

            return merged;




        }



        public ListNode AddTwoNumbers4(ListNode l1, ListNode l2)
        {

            ListNode dummy = new ListNode(0), curr = dummy;
            while (l1 != null || l2 != null || dummy.val != 0)
            { // use dummy.val as carry ;)
                int sum = (l1?.val ?? 0) + (l2?.val ?? 0) + dummy.val;
                dummy.val = sum / 10;
                curr = curr.next = new ListNode(sum % 10);
                l1 = l1.next;
                l2 = l2.next;
            }

            return dummy.next;


        }




        public ListNode AddTwoNumbers3(ListNode l1, ListNode l2)
        {
            if (l1 == null)
                return l2;
            if (l2 == null)
                return l1;
            var head = new ListNode(0);
            var node = head;
            var s1 = ListToStack(l1);
            var s2 = ListToStack(l2);
            var carry = 0;
            while (s1 != null || s2 != null || carry == 1)
            {
                var sum1 = s1.Count > 0 ? s1.Pop() : 0;
                var sum2 = s2.Count > 0 ? s2.Pop() : 0;
                var sum = sum1 + sum2 + carry;
                carry = sum / 10;
                sum %= 10;

                node.next = new ListNode(sum);
                node = node.next;
            }
            return head.next;
        }




        public int MaxSubArrayLen(int[] nums, int k)
        {

            int sum = 0, maxlen = 0;
            Dictionary<int, int> dic = new Dictionary<int, int>() { { 0, -1 } };

            for (int i = 0; i < nums.Length; i++)
            {
                sum += nums[i];

                if (dic.ContainsKey(sum - k))
                    maxlen = Math.Max(maxlen, i - dic[sum - k]);

                if (!dic.ContainsKey(sum))
                    dic.Add(sum, i);
            }

            return maxlen;

        }



        //    {
        //    if (nums == null || nums.Length == 0) return 0;
        //    var i = 0;
        //    var j = nums.Length - 1;
        //    var count = 0;
        //  while (i<j)
        //  {
        //      var total = 0;
        //      for (var index = i; index <=j; index++)
        //      {
        //          total += nums[index];
        //      }

        //      if (total == k)
        //          return j - i + 1;
        //      else if (total > k)
        //          j--;
        //  }
        //    return 0;

        //}



        public ListNode MergeTwoLists2(ListNode l1, ListNode l2)
        {
            var head = new ListNode(0);
            ListNode node = head;

            while (l1 != null && l2 != null)
            {
                if (l1.val <= l2.val)
                {
                    node.next = l1;
                    node = node.next;
                    l1 = l1.next;
                }
                else
                {
                    node.next = l2;
                    node = node.next;
                    l2 = l2.next;
                }
                if (l1 != null) node.next = l1;
                if (l2 != null) node.next = l2;

            }
            return head.next;
        }



        public int[] SortedSquares(int[] A)
        {
            var outarray = new int[A.Length];
            for (var i = 0; i < A.Length; i++)
            {
                outarray[i] = A[i] * A[i];
            }
            Array.Sort(outarray);
            return outarray;
        }

        public string CustomSortString(string S, string T)
        {
            var tlist = T.ToList();
            var resultstr = "";
           
            for (var i = 0; i < S.Length; i++)
            {
                while (tlist.Contains(S[i]))
                {
                    resultstr += S[i];
                    tlist.Remove(S[i]);
                }
            }
            resultstr += new string(tlist.ToArray());
            return resultstr;
        }




        public int[] ProductExceptSelf(int[] nums)
        {
            var len = nums.Length;
            var outarray = new int[len];
            Array.Fill(outarray, 1);

            var product = 1;
            for (var i = 0; i < len - 1; i++)
            {
                product = product * nums[i];
                outarray[i + 1] = product * outarray[i + 1];
            }
            product = 1;
            for (var i = len - 1; i > 0; i--)
            {
                product *= nums[i];
                outarray[i - 1] = product * outarray[i - 1];
            }


            return outarray;
        }





        public int MaxProfit(int[] prices)
        {
            if (prices.Length <= 1)
                return 0;
            var buy = int.MaxValue;
            var sell = 0; // prices[prices.Length - 1];
                          //if (prices.Length == 2)
                          //{
                          //    return (sell - buy) < 0 ? 0 : (sell - buy);
                          //}

            // var i = 
            // var j = prices.Length - 2;



            for (var i = 0; i < prices.Length; i++)
            {
                if (prices[i] < buy)
                {
                    buy = prices[i];
                }
                else
                {
                    sell = Math.Max(sell, prices[i] - buy);
                }

            }



            //while (i <= j)
            //{
            //    if (prices[i] < buy)
            //    {
            //        buy = prices[i];
            //    }
            //    if (prices[j] > sell)
            //    {
            //        sell = prices[j];
            //    }
            //    i++;
            //    j--;
            //}
            return sell; // (sell - buy) < 0 ? 0 : sell - buy;
        }








        public int MinTimeToVisitAllPoints(int[][] points)
        {
            //points.Zip(points.Skip(1), (a, b) => Math.Max(Math.Abs(a[0] - b[0]), Math.Abs(a[1] - b[1]))).Sum();

            var a = points.Zip(points.Skip(1), (a, b) => a[0] + "--" + a[1]); // Math.Max(Math.Abs(a[0] - b[0]), Math.Abs(a[1] - b[1])));

            //.Sum();
            return 1;
            //return a.Sum();

        }

        public string RestoreString(string s, int[] indices)
        {
            var newstring = new StringBuilder();
            for (var i = 0; i < s.Length; i++)
            {
                newstring.Append(s[Array.IndexOf(indices, i)]);
            }
            return newstring.ToString();
        }





       



        //public void TestIcomparable()
        //{
        //    var vals1 = new List<ChrisCustom>() { new ChrisCustom(1), 2 };
        //    var test1 = vals1.OrderBy(l => l);
        //    var test2 = 1;
        //}



        public ListNode AddTwoNumbers2(ListNode l1, ListNode l2)
        {
            Stack<int> stack1 = ListToStack(l1);
            Stack<int> stack2 = ListToStack(l2);

            ListNode head = null;
            int carry = 0;
            while (stack1.Count > 0 || stack2.Count > 0 || carry > 0)
            {
                int val1 = stack1.Count > 0 ? stack1.Pop() : 0;
                int val2 = stack2.Count > 0 ? stack2.Pop() : 0;
                int val = val1 + val2 + carry;
                carry = val / 10;
                val = val % 10;
                ListNode node = new ListNode(val);
                node.next = head;
                head = node;
            }

            return head == null ? new ListNode(0) : head;
        }

        public Stack<int> ListToStack2(ListNode node)
        {
            Stack<int> stack = new Stack<int>();
            while (node != null)
            {
                stack.Push(node.val);
                node = node.next;
            }
            return stack;
        }















        public ListNode AddTwoNumbers1(ListNode l1, ListNode l2)
        {
            var s1 = new Stack<int>();
            var s2 = new Stack<int>();
            while (l1 != null || l2 != null)
            {
                if (l1 != null)
                {
                    s1.Push(l1.val);
                    l1 = l1.next;
                }
                if (l2 != null)
                {
                    s2.Push(l2.val);
                    l2 = l2.next;
                }

            }

            var carry = 0;
            var sum = 0;
            var sumlist = new List<int>();
            while (s1.Count > 0 && s2.Count > 0)
            {
                sum = s1.Pop() + s2.Pop() + carry;
                carry = sum > 9 ? 1 : 0;
                sum = sum > 9 ? sum % 10 : sum;

                sumlist.Add(sum);



            }

            while (s1.Count > 0)
            {
                sum = s1.Pop() + carry;
                carry = sum > 9 ? 1 : 0;
                sum = sum > 9 ? sum % 10 : sum;
                sumlist.Add(sum);

            }
            while (s2.Count > 0)
            {
                sum = s2.Pop() + carry;
                carry = sum > 9 ? 1 : 0;
                sum = sum > 9 ? sum % 10 : sum;
                sumlist.Add(sum);
            }

            if (carry > 0)
                sumlist.Add(carry);
            sumlist.Reverse();
            var newlist = new ListNode(sumlist[0]);
            var head = newlist;
            for (var i = 1; i < sumlist.Count; i++)
            {
                newlist.next = new ListNode(sumlist[i]);
                newlist = newlist.next;
            }
            return head;
        }



        public int LengthOfLongestSubstring(string s)
        {
            var set = new HashSet<char>();
            var count = 0;
            var left = 0;
            var right = 0;

            while (right < s.Length)
            {
                if (!set.Contains(s[right]))
                {
                    set.Add(s[right]);
                    right++;
                    count = Math.Max(count, right - left);

                }
                else
                {
                    set.Remove(s[left]);
                    left++;
                }

            }
            return count;
        }




        public void ReorderList(ListNode head)
        {

            var newlist = head;
            var nodelist = new List<ListNode>();
            var count = 0;

            while (newlist != null)
            {
                count++;
                nodelist.Add(newlist);
                newlist = newlist.next;

            }
            if (count <= 2)
                return;

            var left = 1;
            var right = nodelist.Count - 2;

            newlist = nodelist[0];
            newlist.next = nodelist[count - 1];
            newlist = newlist.next;

            while (left <= right)
            {
                newlist.next = nodelist[left];
                newlist = newlist.next;
                if (left < right)
                {
                    newlist.next = nodelist[right];
                    newlist = newlist.next;
                }
                left++;
                right--;
            }
            newlist.next = null;

        }


        public ListNode RemoveNthFromEnd(ListNode head, int n)
        {
            if (head == null)
                return head;

            var count = 0;
            var firstpass = head;
            while (firstpass != null)
            {
                count++;
                firstpass = firstpass.next;
            }
            firstpass = head;
            if (count == n)
                return head.next;
            count = count - n;
            if (count == 0 && n == 0)
                return null;
            while (count > 1)
            {
                count--;
                firstpass = firstpass.next;
            }


            firstpass.next = firstpass.next.next;
            return head;



        }

        public ListNode MergeKLists(ListNode[] lists)
        {
            if (lists.Count() == 0)
                return null;
            if (lists.Count() == 1)
                return lists[0];
            var newlist = MergeTwoLists(lists[0], lists[1]); //   ListNode(-99999);
            for (var i = 2; i < lists.Length; i++)
            {

                newlist = MergeTwoLists(newlist, lists[i]);
            }
            return newlist.next;
        }



        public ListNode MergeTwoLists(ListNode l1, ListNode l2)
        {
            if (l1 == null)
                return l2;
            if (l2 == null)
                return l1;

            var newlist = new ListNode(0);
            var p = newlist;

            while (l1 != null && l2 != null)
            {
                if (l1.val >= l2.val)
                {
                    p.next = l2;
                    l2 = l2.next;
                }
                else
                {
                    p.next = l1;
                    l1 = l1.next;
                }
                p = p.next;
            }


            if (l1 != null)
            {
                p.next = l1;
            }
            if (l2 != null)
            {
                p.next = l2;
            }

            return newlist.next;

        }




        public ListNode MergeTwoListsTOOSLOW(ListNode l1, ListNode l2)
        {
            ListNode newlist; // = l1.val;
            if (l1.val <= l2.val)
            {
                newlist = new ListNode(l1.val);
                newlist.next = new ListNode(l2.val);
            }
            else
            {
                newlist = new ListNode(l2.val);
                newlist.next = new ListNode(l1.val);
            }
            newlist = newlist.next;
            l1 = l1.next;
            l2 = l2.next;

            while (l1 != null & l2 != null)
            {
                if (l1.val <= l2.val)
                {
                    newlist = new ListNode(l1.val);
                    newlist.next = new ListNode(l2.val);
                }
                else
                {
                    newlist = new ListNode(l2.val);
                    newlist.next = new ListNode(l1.val);
                }
            }
            return newlist;
        }



        public bool HasCycle2Pointer(ListNode head)
        {
            if (head == null)
                return false;
            var fast = head.next;
            var slow = head;
            while (fast != slow)
            {
                if (fast == null || fast.next == null)
                    return false;
                slow = slow.next;
                fast = fast.next.next;
            }
            return true;
        }




        public bool HasCycle(ListNode head)
        {
            var nodes = new Dictionary<ListNode, int>();
            while (head != null)
            {
                if (nodes.ContainsKey(head))
                    return true;
                nodes.Add(head, 1);

                head = head.next;

            }
            return false;
        }



        public bool IsAlienSorted(string[] words, string order)
        {


            for (var i = 0; i < words.Length-1; i++)
                for (var j = i + 1; j < words.Length; j++)
                {
                    var min = Math.Min(words[i].Length, words[j].Length);

                    for (var k = 0; k < min; k++)
                    {
                        if (order.IndexOf(words[i][k]) < order.IndexOf(words[j][k]))
                        {
                            break;
                        }
                        else if (order.IndexOf(words[i][k]) > order.IndexOf(words[j][k]))
                        {
                            return false;
                        }
                        else if (k == min - 1 && words[i].Length > words[j].Length)
                        {
                            return false;
                        }

                    }
                }
            return true;

        }



        public int LengthOfLIS(int[] nums)
        {
            int[] tail = new int[nums.Length];
            int size = 0;
            foreach (int num in nums)
            {
                int i = Array.BinarySearch(tail, 0, size, num);
                if (i < 0) i = -i - 1;
                tail[i] = num;
                if (i == size) size++;
            }
            return size;
        }

        //int minCoins = int.MaxValue;
        //public int CoinChange(int[] coins, int amount)
        //{
        //    if (amount < 0 || coins.Length == 0) return -1;
        //    int coinIndex = coins.Length - 1;
        //    int curCoins = 0;
        //    Array.Sort(coins);
        //    CoinChanges(coins, amount, coinIndex, curCoins);

        //    return minCoins == int.MaxValue ? -1 : minCoins;
        //}

        //public void CoinChanges(int[] coins, int amount, int coinIndex, int curCoins)
        //{
        //    if (coinIndex < 0 || curCoins > minCoins) return;
        //    int c = amount / coins[coinIndex];
        //    for (int i = c; i >= 0; i--)
        //    {
        //        int newCount = curCoins + i;
        //        int remaining = amount - i * coins[coinIndex];
        //        if (remaining == 0) minCoins = Math.Min(minCoins, newCount);
        //        else
        //        {
        //            if (remaining > 0 && minCoins > newCount && coinIndex > 0)
        //            {
        //                CoinChanges(coins, remaining, coinIndex - 1, newCount);
        //            }
        //            else
        //            {
        //                break;
        //            }
        //        }
        //    }
        //}



        public int CoinChange(int[] coins, int amount)
        {
            Array.Sort(coins);
            var dp = new int[amount + 1];
            Array.Fill(dp, amount + 1);
            dp[0] = 0;
            for (var i = 1; i <= amount; i++)
            {
                for (var j = 0; j < coins.Length; j++)
                {
                    if (coins[j] <= i)
                    {
                        dp[i] = Math.Min(dp[i], 1 + dp[i - coins[j]]);
                    }
                    else
                        break;
                }
            }

            return dp[amount] > amount ? -1 : dp[amount];

        }



        public int ClimbStairs1(int n)
        {
            var memo = new int[n + 1];
            return climb_Stairs(0, n, memo);
        }
        public int climb_Stairs(int i, int n, int[] memo)
        {
            if (i > n)
            {
                return 0;
            }
            if (i == n)
            {
                return 1;
            }
            if (memo[i] > 0)
            {
                return memo[i];
            }
            memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
            return memo[i];


        }


        //Works, but way too slow
        //public int ClimbStairs(int n)
        //{
        //    if (n == 0)
        //        return 0;
        //    else if (n == 1)
        //        return 1;
        //    else if (n == 2)
        //        return 2;
        //    else
        //        return ClimbStairs(n - 1) + ClimbStairs(n - 2);
        //}

        //recursion
        public int ClimbStairs3(int n)
        {

            if (n <= 3)
                return n;
            else
            {
                var nm1 = ClimbStairs3(n - 1);
                var nm2 = ClimbStairs3(n - 2);
                return nm1 + nm2;
            }
        }

        public int ClimbStairs(int n)
        {
            return calcstairs(n, new Dictionary<int, int>());


        }




        private int calcstairs(int remaining, Dictionary<int, int> calculated)
        {
            if (remaining < 0)
                return 0;
            else if (remaining == 0)
            {
                return 1;
            }

            else if (calculated.ContainsKey(remaining))
                return calculated[remaining];
            else
            {
                calculated.Add(remaining, calcstairs(remaining - 1, calculated)
                     + calcstairs(remaining - 2, calculated));
                return calculated[remaining];
            }


        }



        public ListNode ReverseList(ListNode head)
        {
            ListNode prev = null;

          //  ListNode curr; // = null;
            while (head != null)

              (head.next,prev,head) = (prev,head,head.next); // TUPLE solution!!!

            //{
            //    curr = head.next;
            //    head.next = prev;
            //    prev = head;
            //    head = curr; // head.next;

            //}
            return prev;
        }



        public void MSInterviewsort012(int[] a)
        {

            int lo = 0;
            int hi = a.Length - 1;
            int mid = 0;
            int temp = 0;

            while (mid <= hi)
            {
                switch (a[mid])
                {
                    case 0:
                        {
                            temp = a[lo];
                            a[lo] = a[mid];
                            a[mid] = temp;
                            lo++;
                            mid++;
                            break;

                        }
                    case 1:
                        {
                            mid++;
                            break;
                        }

                    case 2:
                        {
                            temp = a[mid];
                            a[mid] = a[hi];
                            a[hi] = temp;
                            hi--;
                            break;
                        }
                }
            }
        }



        public bool IsPalindrome(string s)
        {
            //  s = Regex.Replace(s, "^[\\p{L}]+$", ""); // "[^a-zA-Z -]", "");
            s = new string(s.Where(Char.IsLetterOrDigit).ToArray());


            if (s.Length <= 1)
                return true;


            var start = 0;
            var end = s.Length - 1;
            while (start < end)
            {
                if (Char.ToLower(s[start]) != Char.ToLower(s[end]))
                    return false;
                start++;
                end--;
            }
            return true;
        }


        public uint reverseBits(uint n)
        {
            //var r = Convert.ToString(n, 2).PadLeft(32,'0');
            //var s = r.Reverse().ToArray();
            //var t = new String(s);
            // var u = Convert.ToUInt32(t, 2);
            // return u;

            //bitwise
            //int reversed = 0;
            //for (int i = 0; i < 32; i++)
            //{

            //    uint r = 0;
            //    r <<= 1;
            //    var temp = (n & (1 << i));
            //    var temp2 = 1 << (32 - 1 - i);
            //    reversed |= (n & (1 << i)) != 0 ? 1 << (32 - 1 - i) : 0;
            //}
            //return (uint)reversed;

            uint reversed = 0;
            for (int i = 0; i < 4; i++)
            {
                reversed = reversed << 1 | (n & 1);
                n >>= 1;


            }
            return reversed;
        }

        //1 to n
        //0 to n is len * (len+1) / 2;
        public int MissingNumber(int[] nums)
        {
            var len = nums.Length;
            var sum = (len + 1) * len / 2;
            for (var i = 0; i < nums.Length; i++)
            {
                sum -= nums[i];
            }
            return sum;

        }

        public int[] CountBits(int num)
        {
            var bitcounts = new int[num + 1];
            for (var i = 0; i <= num; i++)
            {
                bitcounts[i] = Convert.ToString(i, 2).Replace("0", "").Length;
            }
            return bitcounts;
        }

        public int HammingWeight2(uint n)
        {
            var nstr = Convert.ToString(n, 2);
            var count = nstr.Where(n => n == '1').Count();
            return count;
        }


        //  uint numberbits = 0;
        public int HammingWeight(uint n)
        {
            //non recursive loop.  and to get number bits on lsb thenshift right and repeat.
            //while (n != 0)
            //{
            //    numberbits += n & 1;
            //    n >>= 1;

            //}
            //return Convert.ToInt32(numberbits);


            //recursion1
            //if (n == 0)
            //    return 0; // Convert.ToInt32(numberbits);
            //else
            //{
            //    var numberbits = n & 1;
            //    return (int)numberbits +  HammingWeight( n >> 1);
            //}

            //recursion2

            if (n == 1)
            {
                return (int)n;
            }
            if (n == 0)
            {
                return 0;
            }
            var lg = (uint)(Math.Log(n) / Math.Log(2));
            return 1 + HammingWeight((uint)(n - Math.Pow(2, lg)));

            //converttostring
            //return Convert.ToString(n, 2).Replace("0", "").Length;



        }

        public int GetSum(int a, int b)
        {
            //var list = new List<int>() { a, b };
            //var sum = list.Sum();
            //return sum;
            //if (b == 0)
            //    return a;
            //else
            //{ 
            //    var c = GetSum(a ^ b, (a & b) << 1);
            //    return c;
            //}
            while (b != 0)
            {
                var carry = a & b;
                a = a ^ b;
                b = carry << 1;
            }
            return a;

        }

        public int MaxArea(int[] height)
        {
            var left = 0;
            var right = height.Length - 1;
            var totalarea = 0;
            while (left < right)
            {
                var area = (height[left] < height[right] ? height[left] : height[right]) * (right - left);
                if (height[left] < height[right])
                    left++;
                else
                    right--;

                totalarea = Math.Max(area, totalarea);
            }
            return totalarea;
        }



        public IList<IList<int>> ThreeSum3(int[] nums)
        {
            Array.Sort(nums);
            var sums3 = new List<IList<int>>();
            var dict = nums.GroupBy(n => n).ToDictionary(n => n.Key, n => n.Count());
            var left = 0;
            var right = 0;
            var value = 0;


            for (var i = 0; i < nums.Length - 2; i++)
            {
                left = i + 1;
                right = nums.Length - 1;
                while (left < right)
                {
                    value = -nums[i];
                    if (nums[left] + nums[right] > value)
                    {
                        right--;
                    }
                    else if (nums[left] + nums[right] < value)
                    {
                        left++;
                    }

                    else
                    {
                        sums3.Add(new List<int>() { nums[i], nums[left], nums[right] });

                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    }

                }

                while (i < nums.Length - 2 && nums[i] == nums[i + 1]) i++;
            }
            return sums3;

        }


        public IList<IList<int>> oldThreeSum(int[] nums)
        {
            Array.Sort(nums);
            IList<IList<int>> lists = new List<IList<int>>();

            for (int i = 0; i < nums.Length - 2; i++)
            {
                int left = i + 1;
                int right = nums.Length - 1;
                while (left < right)
                {
                    if (nums[i] == 0 - nums[left] - nums[right])
                    {
                        lists.Add(new List<int>() { nums[i], nums[left], nums[right]
    });

                        // skip dupes
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;

                        left++;
                        right--;

                    }
                    else if (nums[i] < 0 - nums[left] - nums[right])
                    {
                        left++;
                    }
                    else
                    {
                        right--;
                    }
                }

                // skip dupes
                while (i < nums.Length - 1 && nums[i] == nums[i + 1]) i++;
            }

            return lists;
        }





        public IList<IList<int>> ThreeSum(int[] nums)
        {
            Array.Sort(nums);
            var threesums = new List<IList<int>>();
            var len = nums.Length;
            // var dct = nums.GroupBy(n => n).ToDictionary(n => n.Key, n => n.Count());
            for (var i = 0; i < len - 2; i++)
            {
                var left = i + 1;
                var right = len - 1;

                //foreach (KeyValuePair<int, int> pair in dct)
                while (left < right)
                {
                    var val = -nums[i];
                    if (nums[left] + nums[right] > val)
                        right--;
                    else if (nums[left] + nums[right] < val)
                        left++;
                    else
                    {
                        threesums.Add(new List<int>() { nums[i], nums[left], nums[right] });

                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;

                        left++;
                        right--;


                    }


                }
                while (i < len - 1 && nums[i] == nums[i + 1])
                    i++;
            }
            return threesums;

        }

        public int Search(int[] nums, int target)
        {
            var found = Array.IndexOf(nums, target);
            return found;

        }

        public int FindMin(int[] nums)
        {
            for (var i = 0; i < nums.Length - 1; i++)
            {
                if (nums[i + 1] < nums[i])
                {
                    return nums[i + 1];
                }
            }
            return 0;
        }


        public int MaxProduct(int[] nums)
        {
            var maxproduct = nums[0];
            var product = 1;

            for (var i = 0; i < nums.Length; i++)
            {
                product *= nums[i];
                if (product > maxproduct)
                    maxproduct = product;
                if (product == 0)
                    product = 1;
            }

            product = 1;
            for (var i = nums.Length - 1; i >= 0; i--)
            {
                product *= nums[i];
                if (product > maxproduct)
                    maxproduct = product;
                if (product == 0)
                    product = 1;
            }

            return maxproduct;
        }


        //Maximum Subarray
        //Given an integer array nums, find the contiguous subarray(containing at least one number) which has the largest sum and return its sum.
        public int MaxSubArray(int[] nums)
        {
            var sum = nums[0];
            var maxsum = nums[0];

            for (var i = 1; i < nums.Length; i++)
            {
                sum = sum + nums[i] > nums[i] ? sum + nums[i] : nums[i];
                maxsum = sum > maxsum ? sum : maxsum;
            }
            return maxsum;

        }


        public int[] ProductExceptSelf2(int[] nums)
        {
            var outarray = new int[nums.Length];
            Array.Fill(outarray, 1);
            var product = 1;
            for (var i = 0; i < nums.Length - 1; i++)
            {
                product *= nums[i];
                outarray[i + 1] = product * outarray[i + 1];
            }
            product = 1;
            for (var i = nums.Length - 1; i > 0; i--)
            {
                product *= nums[i];
                outarray[i - 1] = product * outarray[i - 1];
            }
            return outarray;
        }



        public bool ContainsDuplicate(int[] nums)
        {

            return nums.Distinct().Count() < nums.Length;

            //var dict = new Dictionary<int, int>();
            //for (var i = 0; i < nums.Length; i++)
            //{
            //    if (dict.ContainsKey(nums[i]))
            //    {
            //        return true;
            //    }
            //    else
            //    {
            //        dict.Add(nums[i], 1);
            //    }
            //}
            //return false;

        }



        public int[] TwoSum(int[] nums, int target)
        {
            var start = 1;
            for (var i = 0; i < nums.Length; i++)
            {
                for (var j = start; j < nums.Length; j++)
                {
                    if (nums[i] + nums[j] == target)
                    {
                        return new int[] { i, j };
                    }
                }
                start++;
            }
            return null;
        }



        public IList<string> CommonChars(string[] A)
        {
            var commonchars = new List<string>();

            var commonchar = false;
            for (var j = 0; j < A[0].Length; j++)
            {

                for (var i = 1; i < A.Length; i++)
                {


                    if (A[i].Contains(A[0][j]))
                    {
                        commonchar = true;
                        var index = A[i].IndexOf(A[0][j]);
                        A[i] = A[i].Remove(index, 1);

                    }
                    else
                    {
                        commonchar = false;
                        break;
                    }
                }
                if (commonchar)
                {
                    commonchars.Add(A[0][j].ToString());
                }
            }
            return commonchars;
        }



        public int NumRollsToTarget2(int d, int f, int target)
        {
            return 1;
        }



        public int[] RelativeSortArray2(int[] arr1, int[] arr2)
        {
            var arr1list = arr1.ToList();
            var newarray = new List<int>();
            for (var i = 0; i < arr2.Length; i++)
            {
                while (arr1list.Contains(arr2[i]))
                {
                    newarray.Add(arr2[i]);
                    arr1list.Remove(arr2[i]);
                }
            }

            if (arr1list.Count > 0)
            {
                arr1list.Sort();
                newarray.AddRange(arr1list);
            }
            return newarray.ToArray();
        }



        public int SumOfLeftLeaves(TreeNode root)
        {
            if (root == null)
                return 0;

            if (root.left != null && root.left.left == null && root.left.right == null)
                return root.left.val + SumOfLeftLeaves(root.left) + SumOfLeftLeaves(root.right);
            else
                return SumOfLeftLeaves(root.left) + SumOfLeftLeaves(root.right);
        }



        public string ciperSolution(string word, string cipher)
        {
            var len = word.Length;
            if (len < 26)
                return "";

            var outstring = new StringBuilder();

            for (var i = 0; i < len; i++)
            {
                var index = char.ToUpper(word[i]) - 64;
                if (index < 0 || index > cipher.Length)
                    return "";
                var a = cipher[index - 1];
                outstring.Append(a);
            }

            return outstring.ToString();
        }






    }




    class PeekingIterator
    {


        List<int> list = new List<int>();


        // iterators refers to the first element of the array.
        public PeekingIterator(List<int> iterator) // IEnumerator<int> iterator)
        {

            list.AddRange(iterator);

        }

        // Returns the next element in the iteration without advancing the iterator.
        public int Peek()
        {
            return list[0];
        }

        // Returns the next element in the iteration and advances the iterator.
        public int Next()
        {
            if (list.Count > 0)
            {
                var val = list[0];
                list.RemoveAt(0);
                return val;
            }
            else
                return 0;
        }

        // Returns false if the iterator is refering to the end of the array of true otherwise.
        public bool HasNext()
        {
            if (list.Count > 0)
                return true;
            else
                return false;
        }
    }



    public class MyStack
    {

        Queue q1;
        Queue q2;

        public MyStack()
        {
            q1 = new Queue();
            q2 = new Queue();
        }


        public void Push(int x)
        {
            while (q1.Count > 0)
            {
                var item = q1.Dequeue();
                q2.Enqueue(item);
            }
            q1.Enqueue(x);
        }

        public int Peek()
        {
            return Convert.ToInt32(q1.Peek());
        }


        public int Pop()
        {
            var item = Convert.ToInt32(q1.Dequeue());
            while (q2.Count > 0)
            {
                var q2item = q2.Dequeue();
                q1.Enqueue(q2item);
            }

            while (q1.Count > 1)
            {
                var q1item = q1.Dequeue();
                q2.Enqueue(q1item);
            }



            return item;
        }




    }



    public class MyQueue
    {

        Stack<int> s1;
        Stack<int> s2;

        /** Initialize your data structure here. */
        public MyQueue()
        {
            s1 = new Stack<int>();
            s2 = new Stack<int>();
        }

        /** Push element x to the back of queue. */
        public void Push(int x)
        {
            while (s2.Count > 0)
            {
                var e = s2.Pop();
                s1.Push(e);
            }
            s2.Push(x);
            while (s1.Count > 0)
            {
                s2.Push(s1.Pop());
            }
        }

        /** Removes the element from in front of queue and returns that element. */
        public int Pop()
        {
            return s2.Pop();
        }

        /** Get the front element. */
        public int Peek()
        {
            return s2.Peek();
        }

        /** Returns whether the queue is empty. */
        public bool Empty()
        {
            return s2.Count == 0;
        }
    }


    class MyStack2
    {

        Queue<int> q1 = new Queue<int>();

        internal void Push(int val)
        {
            var q2 = new Queue<int>();
            while (q1.Count > 0)
            {
                q2.Enqueue(q1.Dequeue());
            }
            q1.Enqueue(val);
            while (q2.Count > 0)
            {
                q1.Enqueue(q2.Dequeue());
            }


        }

        internal int Pop()
        {
            return q1.Dequeue();
        }

        internal int Peek()
        {
            return q1.Peek();
        }

        internal bool IsEmpty()
        {
            return q1.Count == 0;
        }


    }




    class TrieNode
    {
        public Dictionary<char, TrieNode> children = new Dictionary<char, TrieNode>();
        public string word = null;
        public TrieNode() { }
    }








    public class MyCircularQueueListNode
    {
        ListNode front;
        ListNode rear;

        int capacity;
        int count = 0;

        public MyCircularQueueListNode(int k)
        {
            rear = new ListNode(-1);
            front = rear;
            capacity = k;
        }

        public bool EnQueue(int value)
        {
            if (count == capacity)
                return false;
            if (rear.val == -1)
                rear.val = value;
            else
            {
                rear.next = new ListNode(value);
                rear = rear.next;
                count++;
            }
            count++;

            return true;
        }

        public bool DeQueue()
        {
            if (count == 0)
                return false;
            if (count == 1)
            {
                front.val = -1;
            }
            else
            {
                front = front.next;
            }
            count--;
            return true;
        }

        public int Front()
        {
            if (count == 0)
                return -1;
            return front.val;
        }

        public int Rear()
        {
            if (count == 0)
                return -1;
            return rear.val;
        }

        public bool IsEmpty()
        {
            return count == 0;
        }

        public bool IsFull()
        {
            return count == capacity;
        }
    }












    public class MyCircularQueue
    {
        Queue queue;
        int capacity;

        public MyCircularQueue(int k)
        {
            queue = new Queue(k);
            capacity = k;
        }

        public bool EnQueue(int value)
        {
            if (queue.Count == capacity)
                return false;
            queue.Enqueue(value);
            return true;
        }

        public bool DeQueue()
        {
            if (queue.Count == 0)
                return false;
            queue.Dequeue();
            return true;
        }

        public int Front()
        {
            if (queue.Count == 0)
                return -1;
            return Convert.ToInt32(queue.Peek());
        }

        public int Rear()
        {
            if (queue.Count == 0)
                return -1;
            var q2 = new Queue();
            while (queue.Count > 1)
            {
                q2.Enqueue(Convert.ToInt32(queue.Dequeue()));
            }
            var item = Convert.ToInt32(queue.Peek());
            q2.Enqueue(Convert.ToInt32(queue.Dequeue()));
            while (q2.Count > 0)
            {
                queue.Enqueue(Convert.ToInt32(q2.Dequeue()));
            }
            return item;
        }

        public bool IsEmpty()
        {
            return queue.Count == 0;
        }

        public bool IsFull()
        {
            return queue.Count == capacity;
        }
    }








    //["UndergroundSystem","checkIn","checkIn","checkOut","checkIn","checkOut","checkOut","checkIn","getAverageTime","getAverageTime","checkIn","checkIn","getAverageTime"]
    //[[],[],[],[],[,[],[],],["],[],[],],[]]









    //public class UndergroundSystem
    //{

    //    Dictionary<string, List<int>> result;
    //    Dictionary<int, CheckIn> checkIns;

    //    public UndergroundSystem()
    //    {
    //        result = new Dictionary<string, List<int>>();
    //        checkIns = new Dictionary<int, CheckIn>();
    //    }

    //    public void CheckIn(int id, string stationName, int t)
    //    {
    //        checkIns[id] = new CheckIn() { stationName = stationName, time = t };
    //    }

    //    public void CheckOut(int id, string stationName, int t)
    //    {
    //        var checkInInfo = checkIns[id];
    //        string key = checkInInfo.stationName + ":" + stationName;
    //        int duration = t - checkInInfo.time;
    //        if (!result.ContainsKey(key))
    //            result[key] = new List<int>();
    //        result[key].Add(duration);
    //        checkIns.Remove(id);
    //    }

    //    public double GetAverageTime(string startStation, string endStation)
    //    {
    //        string key = startStation + ":" + endStation;
    //        return (double)(result[key].Sum()) / (double)(result[key].Count);

    //    }
    //}

    //public class CheckIn
    //{
    //    public string stationName;
    //    public int time;
    //}



    public class UndergroundSystem
    {

        private class checkin
        {


            internal string checkinstationname { get; set; }
            internal int checkintime { get; set; }

        }

        Dictionary<int, checkin> checkins = new Dictionary<int, checkin>();
        Dictionary<string, List<int>> completed = new Dictionary<string, List<int>>();

        public UndergroundSystem()
        {

        }

        public void checkIn(int id, string stationName, int t)
        {
            checkins[id] = new checkin()
            {
                checkinstationname = stationName,
                checkintime = t
            };
        }

        public void checkOut(int id, string stationName, int t)
        {

            var total = t - checkins[id].checkintime;
            var newkey = checkins[id].checkinstationname + ":" + stationName;

            if (!completed.ContainsKey(newkey))
            {
                completed.Add(newkey, new List<int>());
            }
            completed[newkey].Add(total);

        }

        public double getAverageTime(string startStation, string endStation)
        {
            var times = completed[startStation + ":" + endStation];
            var count = times.Count;

            var sum = 0;



            for (var i = 0; i < count; i++)
            {
                sum += times[i];
            }

            var average = (double)sum / (double)count;

            return average;
        }
    }

    /**
     * Your UndergroundSystem object will be instantiated and called as such:
     * UndergroundSystem obj = new UndergroundSystem();
     * obj.CheckIn(id,stationName,t);
     * obj.CheckOut(id,stationName,t);
     * double param_3 = obj.GetAverageTime(startStation,endStation);
     */









    /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int x) { val = x; }
 * }
 */
    public class Codec
    {

        StringBuilder serialized = new StringBuilder();
        // Encodes a tree to a single string.
        public string serialize(TreeNode root)
        {
            if (root == null)
            {
                serialized.Append("M");
                serialized.Append(",");
                return null;
            }
            serialized.Append(root.val + ",");
            serialize(root.left);
            serialize(root.right);
            return serialized.ToString();
        }

        // Decodes your encoded data to tree.
        public TreeNode deserialize(string data)
        {
            if (data == null)
                return null;
            var strs = data.Split(',', StringSplitOptions.RemoveEmptyEntries).ToList();
            return dodeser(strs);
        }

        private TreeNode dodeser(List<string> strs)
        {

            if (strs[0] == "M")
                return null;
            var node = new TreeNode(Convert.ToInt32(strs[0]));
            strs.Remove(strs[0]);
            node.left = dodeser(strs);
            strs.Remove(strs[0]);
            node.right = dodeser(strs);
            return node;
        }


    }

    // Your Codec object will be instantiated and called as such:
    // Codec ser = new Codec();
    // Codec deser = new Codec();
    // TreeNode ans = deser.deserialize(ser.serialize(root));










}





